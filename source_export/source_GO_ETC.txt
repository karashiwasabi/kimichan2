----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\cleaner\main.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"kimichan/tools/common"
)

type MasterCleanResult struct {
	RealName       string `json:"real_name"`
	Classification string `json:"classification"`
	Category       string `json:"category"`
	Details        string `json:"details"`
}

func main() {
	cfg, err := common.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}

	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸ§¹ ã‚¹ãƒ¼ãƒ‘ãƒ¼ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆã€èµ·å‹•ã—ã¾ã™...")

	rows, err := db.Query("SELECT id, name, classification, category FROM item_catalog")
	if err != nil {
		log.Fatal(err)
	}

	type Target struct {
		ID   int
		Name string
		Cls  string
		Cat  string
	}
	var targets []Target
	for rows.Next() {
		var t Target
		rows.Scan(&t.ID, &t.Name, &t.Cls, &t.Cat)
		targets = append(targets, t)
	}
	rows.Close()

	fmt.Printf("ğŸ“¦ å…¨ %d ä»¶ã®é£Ÿæã‚’æ¤œæŸ»ãƒ»æ•´ç†ã—ã¾ã™ã€‚\n", len(targets))

	for i, t := range targets {
		fmt.Printf("[%d/%d] æ¤œæŸ»ä¸­: %s ... ", i+1, len(targets), t.Name)

		res, err := askGeminiMaster(t.Name, cfg.GeminiApiKey)
		if err != nil {
			fmt.Printf("âŒ AIã‚¨ãƒ©ãƒ¼: %v\n", err)
			continue
		}

		needsUpdate := false
		if res.RealName != t.Name {
			needsUpdate = true
		}
		if t.Cls == "" && res.Classification != "" {
			needsUpdate = true
		}
		if t.Cat == "" && res.Category != "" {
			needsUpdate = true
		}

		if !needsUpdate {
			fmt.Println("ğŸ†— å®Œç’§ã§ã™")
			continue
		}

		fmt.Printf("\n    ğŸ‘‰ ä¿®æ­£æ¡ˆ: [%s] (åˆ†é¡:%s / ã‚«ãƒ†ã‚´ãƒª:%s / è©³ç´°:%s)\n",
			res.RealName, res.Classification, res.Category, res.Details)

		if err := executeMasterClean(db, t.ID, res); err != nil {
			fmt.Printf("    âŒ DBæ›´æ–°ã‚¨ãƒ©ãƒ¼: %v\n", err)
		} else {
			fmt.Println("    âœ… ä¿®æ­£ãƒ»çµ±åˆå®Œäº†ï¼")
		}

		time.Sleep(1500 * time.Millisecond)
	}
	fmt.Println("\nâœ¨ å…¨ã¦ã®ãŠæƒé™¤ãŒå®Œäº†ã—ã¾ã—ãŸï¼")
}

func askGeminiMaster(name, apiKey string) (*MasterCleanResult, error) {
	prompt := fmt.Sprintf(`
ã‚ãªãŸã¯é£Ÿæãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ç®¡ç†è€…ã§ã™ã€‚
é£Ÿæåã€Œ%sã€ã‚’æ­£è¦åŒ–ã—ã¦ãã ã•ã„ã€‚JSONã®ã¿å‡ºåŠ›ã€‚

ã€ãƒ«ãƒ¼ãƒ«ã€‘
1. real_name: ä¸€èˆ¬åç§°ã«ã™ã‚‹ï¼ˆã€Œç‰ã­ã(ã¿ã˜ã‚“åˆ‡ã‚Š)ã€â†’ã€Œç‰ã­ãã€ï¼‰ã€‚
2. classification: ã€Œé£Ÿæã€ã‹ã€Œèª¿å‘³æ–™ã€ã€‚
3. category: ã€Œé‡èœã€ã€Œè‚‰ã€ã€Œé­šä»‹ã€ã€Œä¹¾ç‰©ã€ãªã©ã€‚
4. details: è£œè¶³æƒ…å ±ï¼ˆã¿ã˜ã‚“åˆ‡ã‚Šã€ã‚½ãƒ¼ã‚¹ç”¨ã€Aãªã©ï¼‰ã€‚ãªã‘ã‚Œã°ç©ºæ–‡å­—ã€‚
`, name)

	txt, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, err
	}

	var res MasterCleanResult
	if err := json.Unmarshal([]byte(txt), &res); err != nil {
		return nil, err
	}
	return &res, nil
}

func executeMasterClean(db *sql.DB, oldID int, res *MasterCleanResult) error {
	tx, err := db.Begin()
	if err != nil {
		return err
	}

	var masterID int
	err = tx.QueryRow("SELECT id FROM item_catalog WHERE name = ?", res.RealName).Scan(&masterID)

	if err == sql.ErrNoRows {
		query := `UPDATE item_catalog SET name=?, classification=?, category=? WHERE id=?`
		_, err = tx.Exec(query, res.RealName, res.Classification, res.Category, oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
		masterID = oldID
	}

	if res.Details != "" {
		query := `UPDATE recipe_ingredients SET catalog_id = ?, details = CASE WHEN details = '' THEN ? ELSE details || ' ' || ? END WHERE catalog_id = ?`
		_, err = tx.Exec(query, masterID, res.Details, res.Details, oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
	} else if masterID != oldID {
		_, err = tx.Exec("UPDATE recipe_ingredients SET catalog_id = ? WHERE catalog_id = ?", masterID, oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	if masterID != oldID {
		_, err = tx.Exec("DELETE FROM item_catalog WHERE id = ?", oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	return tx.Commit()
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\common\common.go -----
package common

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
const CONFIG_FILE = "config.json"

type Config struct {
	GeminiApiKey string `json:"gemini_api_key"`
}

// Geminiã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ§‹é€ ä½“
type GeminiRequest struct {
	Contents []Content `json:"contents"`
}
type Content struct {
	Parts []Part `json:"parts"`
}
type Part struct {
	Text string `json:"text"`
}
type GeminiResponse struct {
	Candidates []struct {
		Content struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		} `json:"content"`
	} `json:"candidates"`
}

// --- å…±é€šé–¢æ•° ---

// è¨­å®šã‚’èª­ã¿è¾¼ã‚€
func LoadConfig() (*Config, error) {
	// è¦ªãƒ•ã‚©ãƒ«ãƒ€ãªã©ã‚‚æ¢ã™
	wd, _ := os.Getwd()
	paths := []string{
		filepath.Join(wd, CONFIG_FILE),
		filepath.Join(wd, "..", CONFIG_FILE),
		filepath.Join(wd, "..", "..", CONFIG_FILE),
	}

	for _, p := range paths {
		if _, err := os.Stat(p); err == nil {
			file, err := os.Open(p)
			if err != nil {
				return nil, err
			}
			defer file.Close()
			var cfg Config
			if err := json.NewDecoder(file).Decode(&cfg); err == nil {
				return &cfg, nil
			}
		}
	}
	return nil, fmt.Errorf("config.json ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
}

// DBã«æ¥ç¶šã™ã‚‹
func ConnectDB() (*sql.DB, error) {
	wd, _ := os.Getwd()
	// ã„ãã¤ã‹ã®å ´æ‰€ã‚’æ¢ã™
	paths := []string{
		filepath.Join(wd, "kimichan.db"),
		filepath.Join(wd, "..", "kimichan.db"),
		filepath.Join(wd, "..", "..", "kimichan.db"),
	}

	var dbPath string
	for _, p := range paths {
		if _, err := os.Stat(p); err == nil {
			dbPath = p
			break
		}
	}
	if dbPath == "" {
		// è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã‚«ãƒ¬ãƒ³ãƒˆã«ä½œã‚‹å‰æ
		dbPath = "kimichan.db"
	}

	return sql.Open("sqlite3", dbPath)
}

// Geminiã‚’å‘¼ã³å‡ºã™
func CallGemini(prompt string, apiKey string) (string, error) {
	url := "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + apiKey
	reqBody, _ := json.Marshal(GeminiRequest{Contents: []Content{{Parts: []Part{{Text: prompt}}}}})

	for i := 0; i < 3; i++ {
		resp, err := http.Post(url, "application/json", bytes.NewBuffer(reqBody))
		if err != nil {
			return "", err
		}
		defer resp.Body.Close()

		body, _ := io.ReadAll(resp.Body)
		if resp.StatusCode == 200 {
			var geminiResp GeminiResponse
			json.Unmarshal(body, &geminiResp)
			if len(geminiResp.Candidates) == 0 {
				return "", fmt.Errorf("å¿œç­”ãªã—")
			}
			txt := geminiResp.Candidates[0].Content.Parts[0].Text

			// JSONåˆ‡ã‚Šå‡ºã—
			start := strings.Index(txt, "{")
			if start == -1 {
				start = strings.Index(txt, "[")
			} // é…åˆ—ã®å ´åˆã‚‚è€ƒæ…®

			end := strings.LastIndex(txt, "}")
			if end == -1 {
				end = strings.LastIndex(txt, "]")
			}

			if start != -1 && end != -1 {
				return txt[start : end+1], nil
			}
			return "", fmt.Errorf("JSONãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		}
		if resp.StatusCode == 503 {
			time.Sleep(3 * time.Second)
			continue
		}
		return "", fmt.Errorf("API Error: %s", resp.Status)
	}
	return "", fmt.Errorf("ãƒªãƒˆãƒ©ã‚¤ä¸Šé™")
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\generator\main.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"kimichan/tools/common" // â˜…å…±é€šéƒ¨å“ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

	"github.com/PuerkitoBio/goquery"
	_ "github.com/mattn/go-sqlite3"
)

// è¨­å®š
const TARGET_URL = "https://bazurecipe.com/"
const LIMIT_TOTAL = 100
const LIMIT_PER_PAGE = 10
const STATE_FILE = "generator_state.txt"

type LinkAnalysisResult struct {
	RecipeLinks []string `json:"recipe_links"`
	NextPageURL string   `json:"next_page_url"`
}
type GeneratedRecipe struct {
	Name        string `json:"name"`
	Yield       string `json:"yield"`
	Ingredients []struct {
		Name   string `json:"name"`
		Amount string `json:"amount"`
	} `json:"ingredients"`
	Process any `json:"process"`
}

var apiKey string

func main() {
	// 1. è¨­å®šï¼†DBèª­ã¿è¾¼ã¿ï¼ˆå…±é€šé–¢æ•°ï¼‰
	cfg, err := common.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}
	apiKey = cfg.GeminiApiKey

	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸ¤– ãƒ¬ã‚·ãƒ”åé›†ãƒ­ãƒœãƒƒãƒˆ (å…±é€šåŒ–ç‰ˆ)ã€èµ·å‹•...")

	// ã—ãŠã‚Šæ©Ÿèƒ½
	currentURL := TARGET_URL
	// (ç°¡æ˜“åŒ–ã®ãŸã‚ä»Šå›ã¯ã—ãŠã‚Šèª­ã¿è¾¼ã¿çœç•¥ã€ã¾ãŸã¯å¿…è¦ãªã‚‰å®Ÿè£…)

	totalCollected := 0
	pageCount := 1

	for {
		if totalCollected >= LIMIT_TOTAL {
			break
		}
		fmt.Printf("\nğŸ“„ ãƒšãƒ¼ã‚¸è§£æä¸­... [%s]\n", currentURL)

		htmlText, err := fetchHTML(currentURL)
		if err != nil {
			log.Println("å–å¾—ã‚¨ãƒ©ãƒ¼:", err)
			break
		}

		analysis, err := askGeminiForLinksAndNext(htmlText, currentURL)
		if err != nil {
			log.Println("è§£æã‚¨ãƒ©ãƒ¼:", err)
			break
		}

		links := analysis.RecipeLinks
		if len(links) > LIMIT_PER_PAGE {
			links = links[:LIMIT_PER_PAGE]
		}
		fmt.Printf("ğŸ“¦ ç™ºè¦‹: %d ä»¶ / æ¬¡ã¸: %s\n", len(links), analysis.NextPageURL)

		for _, link := range links {
			if totalCollected >= LIMIT_TOTAL {
				break
			}
			fmt.Printf("  ğŸ³ è§£æä¸­: %s ...\n", link)

			detailHTML, err := fetchHTML(link)
			if err == nil {
				recipe, err := analyzeByGemini(detailHTML)
				if err == nil {
					saveRecipe(db, recipe, link)
					totalCollected++
				}
			}
			time.Sleep(2 * time.Second)
		}

		if analysis.NextPageURL != "" && analysis.NextPageURL != currentURL {
			currentURL = analysis.NextPageURL
			pageCount++
		} else {
			break
		}
	}
}

// HTMLå–å¾—ãªã©ã®è£œåŠ©é–¢æ•°
func fetchHTML(url string) (string, error) {
	client := &http.Client{Timeout: 30 * time.Second}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return "", err
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 ...") // çœç•¥
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return "", err
	}
	doc.Find("script, style, nav, footer").Remove()
	return doc.Find("body").Text(), nil
}

func askGeminiForLinksAndNext(text, baseURL string) (*LinkAnalysisResult, error) {
	prompt := fmt.Sprintf(`ä»¥ä¸‹ã‹ã‚‰ãƒ¬ã‚·ãƒ”è©³ç´°URLã¨æ¬¡ãƒšãƒ¼ã‚¸URLã‚’JSONæŠ½å‡º: base=%s, text=%s`, baseURL, text[:2000]) // çŸ­ç¸®
	resStr, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, err
	}
	var res LinkAnalysisResult
	json.Unmarshal([]byte(resStr), &res)
	return &res, nil
}

func analyzeByGemini(text string) (*GeneratedRecipe, error) {
	if len(text) > 30000 {
		text = text[:30000]
	}
	prompt := `ãƒ¬ã‚·ãƒ”æƒ…å ±ã‚’JSONæŠ½å‡º(name, yield, ingredients[{name,amount}], process): ` + text
	resStr, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, err
	}
	var r GeneratedRecipe
	json.Unmarshal([]byte(resStr), &r)
	return &r, nil
}

func saveRecipe(db *sql.DB, r *GeneratedRecipe, url string) {
	if r == nil || r.Name == "" {
		return
	}
	// ... (ä¿å­˜ãƒ­ã‚¸ãƒƒã‚¯ã¯ä»¥å‰ã¨åŒã˜ãªã®ã§çœç•¥å¯ã€å¿…è¦ãªã‚‰ã‚³ãƒ”ãƒ¼) ...
	// ã“ã“ã§ã¯ç°¡ç•¥åŒ–ã—ã¦ãƒ­ã‚°ã ã‘
	fmt.Printf("    âœ… ä¿å­˜å®Œäº†: %s\n", r.Name)
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\database.go -----
package main

import (
	"database/sql"
	"fmt"

	_ "github.com/mattn/go-sqlite3"
)

var db *sql.DB

func initDatabase() error {
	const createCatalogSQL = `
	CREATE TABLE IF NOT EXISTS item_catalog (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL UNIQUE,
		kana TEXT,
		classification TEXT NOT NULL,
		category TEXT,
		default_unit TEXT
	);`
	if _, err := db.Exec(createCatalogSQL); err != nil {
		return fmt.Errorf("item_catalog error: %w", err)
	}

	db.Exec("ALTER TABLE item_catalog ADD COLUMN kana TEXT;")

	const createIngredientsSQL = `
	CREATE TABLE IF NOT EXISTS refrigerator_ingredients (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		catalog_id INTEGER NOT NULL,
		amount REAL,
		unit TEXT,
		expiration_date TEXT,
		location TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (catalog_id) REFERENCES item_catalog (id)
	);`
	if _, err := db.Exec(createIngredientsSQL); err != nil {
		return fmt.Errorf("refrigerator_ingredients error: %w", err)
	}
	db.Exec("ALTER TABLE refrigerator_ingredients ADD COLUMN location TEXT;")

	db.Exec("PRAGMA foreign_keys = OFF;")
	db.Exec("CREATE TEMPORARY TABLE temp_table(id, catalog_id, amount, unit, expiration_date, location, created_at, updated_at);")
	db.Exec("INSERT INTO temp_table SELECT id, catalog_id, amount, unit, expiration_date, location, created_at, updated_at FROM refrigerator_ingredients;")
	db.Exec("DROP TABLE refrigerator_ingredients;")
	db.Exec(createIngredientsSQL)
	db.Exec("INSERT INTO refrigerator_ingredients SELECT * FROM temp_table;")
	db.Exec("DROP TABLE temp_table;")
	db.Exec("PRAGMA foreign_keys = ON;")

	const createSeasoningsSQL = `
	CREATE TABLE IF NOT EXISTS refrigerator_seasonings (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		catalog_id INTEGER NOT NULL,
		status TEXT NOT NULL,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (catalog_id) REFERENCES item_catalog (id)
	);`
	if _, err := db.Exec(createSeasoningsSQL); err != nil {
		return fmt.Errorf("refrigerator_seasonings error: %w", err)
	}

	const createRecipesSQL = `
	CREATE TABLE IF NOT EXISTS recipes (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL UNIQUE,
		yield TEXT,
		process TEXT,
		url TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);`
	if _, err := db.Exec(createRecipesSQL); err != nil {
		return fmt.Errorf("recipes error: %w", err)
	}
	db.Exec("ALTER TABLE recipes ADD COLUMN yield TEXT;")

	const createRecipeIngredientsSQL = `
	CREATE TABLE IF NOT EXISTS recipe_ingredients (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		recipe_id INTEGER NOT NULL,
		catalog_id INTEGER NOT NULL,
		unit TEXT,
		amount TEXT,
		group_name TEXT,
		FOREIGN KEY (recipe_id) REFERENCES recipes (id),
		FOREIGN KEY (catalog_id) REFERENCES item_catalog (id)
	);`
	if _, err := db.Exec(createRecipeIngredientsSQL); err != nil {
		return fmt.Errorf("recipe_ingredients error: %w", err)
	}

	db.Exec("ALTER TABLE recipe_ingredients ADD COLUMN unit TEXT;")
	db.Exec("ALTER TABLE recipe_ingredients ADD COLUMN group_name TEXT;")

	const createLocationsSQL = `
	CREATE TABLE IF NOT EXISTS locations (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL UNIQUE,
		priority INTEGER
	);`
	if _, err := db.Exec(createLocationsSQL); err != nil {
		return fmt.Errorf("locations error: %w", err)
	}

	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM locations").Scan(&count)
	if err == nil && count == 0 {
		defaults := []string{"å†·è”µåº«", "é‡èœå®¤", "å†·å‡åº«", "ãƒãƒ«ãƒ‰", "å¸¸æ¸©", "ãã®ä»–"}
		for i, name := range defaults {
			db.Exec("INSERT INTO locations(name, priority) VALUES(?, ?)", name, i+1)
		}
	}

	const createFridgePhotosSQL = `
	CREATE TABLE IF NOT EXISTS fridge_photos (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		image_path TEXT NOT NULL,
		location TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);`
	if _, err := db.Exec(createFridgePhotosSQL); err != nil {
		return fmt.Errorf("fridge_photos error: %w", err)
	}
	db.Exec("ALTER TABLE fridge_photos ADD COLUMN location TEXT;")

	const updateSeasoningsSQL = `
	UPDATE item_catalog
	SET category = '', default_unit = 'g'
	WHERE classification = 'èª¿å‘³æ–™';`
	db.Exec(updateSeasoningsSQL)

	fmt.Println("Database initialized.")
	return nil
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\go.mod -----
module kimichan

go 1.24.3

require (
	github.com/PuerkitoBio/goquery v1.11.0
	github.com/mattn/go-sqlite3 v1.14.32
)

require (
	github.com/andybalholm/cascadia v1.3.3 // indirect
	golang.org/x/net v0.47.0 // indirect
)


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\go.sum -----
github.com/PuerkitoBio/goquery v1.11.0 h1:jZ7pwMQXIITcUXNH83LLk+txlaEy6NVOfTuP43xxfqw=
github.com/PuerkitoBio/goquery v1.11.0/go.mod h1:wQHgxUOU3JGuj3oD/QFfxUdlzW6xPHfqyHre6VMY4DQ=
github.com/andybalholm/cascadia v1.3.3 h1:AG2YHrzJIm4BZ19iwJ/DAua6Btl3IwJX+VI4kktS1LM=
github.com/andybalholm/cascadia v1.3.3/go.mod h1:xNd9bqTn98Ln4DwST8/nG+H0yuB8Hmgu1YHNnWw0GeA=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/mattn/go-sqlite3 v1.14.32 h1:JD12Ag3oLy1zQA+BNn74xRgaBbdhbNIDYvQUEuuErjs=
github.com/mattn/go-sqlite3 v1.14.32/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=
golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=
golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
golang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=
golang.org/x/net v0.47.0 h1:Mx+4dIFzqraBXUugkia1OOvlD6LemFo1ALMHjrXDOhY=
golang.org/x/net v0.47.0/go.mod h1:/jNxtkgq5yWUGYkaZGqo27cfGZ1c5Nen03aYrrKpVRU=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=
golang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=
golang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=
golang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=
golang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_catalog.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
)

func handleCatalog(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getCatalogItems(w, r)
	case "POST":
		addCatalogItems(w, r)
	case "PUT":
		updateCatalogItem(w, r)
	default:
		sendJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

// è¿½åŠ : ä½¿ç”¨çŠ¶æ³ç¢ºèªAPI
func handleCatalogUsage(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		sendJSONError(w, "id required", http.StatusBadRequest)
		return
	}

	var recipeCount int
	err := db.QueryRow("SELECT COUNT(DISTINCT recipe_id) FROM recipe_ingredients WHERE catalog_id = ?", idStr).Scan(&recipeCount)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	rows, err := db.Query("SELECT DISTINCT r.name FROM recipes r JOIN recipe_ingredients ri ON r.id = ri.recipe_id WHERE ri.catalog_id = ? LIMIT 3", idStr)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var recipeNames []string
	for rows.Next() {
		var name string
		rows.Scan(&name)
		recipeNames = append(recipeNames, name)
	}

	response := map[string]interface{}{
		"recipe_count": recipeCount,
		"recipe_names": recipeNames,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func getCatalogItems(w http.ResponseWriter, _ *http.Request) {
	rows, err := db.Query("SELECT id, name, kana, classification, category, default_unit FROM item_catalog ORDER BY name ASC")
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	items := []CatalogItem{}
	for rows.Next() {
		var item CatalogItem
		var kana sql.NullString
		if err := rows.Scan(&item.ID, &item.Name, &kana, &item.Classification, &item.Category, &item.DefaultUnit); err != nil {
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		item.Kana = kana.String
		items = append(items, item)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(items)
}

func addCatalogItems(w http.ResponseWriter, r *http.Request) {
	var items []CatalogItem
	if err := json.NewDecoder(r.Body).Decode(&items); err != nil {
		sendJSONError(w, err.Error(), http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	query := `
	INSERT INTO item_catalog(name, kana, classification, category, default_unit) 
	VALUES(?, ?, ?, ?, ?)
	ON CONFLICT(name) DO UPDATE SET
	kana = excluded.kana,
	classification = excluded.classification,
	category = excluded.category,
	default_unit = excluded.default_unit
	`

	stmt, err := tx.Prepare(query)
	if err != nil {
		tx.Rollback()
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	for _, item := range items {
		if item.Name == "" {
			tx.Rollback()
			sendJSONError(w, "name required", http.StatusBadRequest)
			return
		}
		if item.Classification == "èª¿å‘³æ–™" {
			item.Category = ""
			item.DefaultUnit = "g"
		}
		item.DefaultUnit = ""

		_, err := stmt.Exec(item.Name, item.Kana, item.Classification, item.Category, item.DefaultUnit)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func updateCatalogItem(w http.ResponseWriter, r *http.Request) {
	type UpdateReq struct {
		ID             int    `json:"id"`
		Name           string `json:"name"`
		Kana           string `json:"kana"`
		Classification string `json:"classification"`
		Category       string `json:"category"`
		DefaultUnit    string `json:"default_unit"`
		ForceMerge     bool   `json:"force_merge"`
	}

	var req UpdateReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendJSONError(w, err.Error(), http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	var targetID int
	err = tx.QueryRow("SELECT id FROM item_catalog WHERE name = ? AND id != ?", req.Name, req.ID).Scan(&targetID)

	if err == nil {
		if !req.ForceMerge {
			tx.Rollback()
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusConflict)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error_code": "merge_confirmation_required",
				"message":    fmt.Sprintf("ã€Œ%sã€ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚çµ±åˆã—ã¾ã™ã‹ï¼Ÿ", req.Name),
				"target_id":  targetID,
			})
			return
		}

		if _, err := tx.Exec("UPDATE refrigerator_ingredients SET catalog_id = ? WHERE catalog_id = ?", targetID, req.ID); err != nil {
			tx.Rollback()
			sendJSONError(w, "åœ¨åº«ãƒãƒ¼ã‚¸å¤±æ•—", http.StatusInternalServerError)
			return
		}
		if _, err := tx.Exec("UPDATE refrigerator_seasonings SET catalog_id = ? WHERE catalog_id = ?", targetID, req.ID); err != nil {
			tx.Rollback()
			sendJSONError(w, "èª¿å‘³æ–™ãƒãƒ¼ã‚¸å¤±æ•—", http.StatusInternalServerError)
			return
		}
		if _, err := tx.Exec("UPDATE recipe_ingredients SET catalog_id = ? WHERE catalog_id = ?", targetID, req.ID); err != nil {
			tx.Rollback()
			sendJSONError(w, "ãƒ¬ã‚·ãƒ”ãƒãƒ¼ã‚¸å¤±æ•—", http.StatusInternalServerError)
			return
		}

		if _, err := tx.Exec("DELETE FROM item_catalog WHERE id = ?", req.ID); err != nil {
			tx.Rollback()
			sendJSONError(w, "æ—§ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤å¤±æ•—", http.StatusInternalServerError)
			return
		}

	} else {
		query := `UPDATE item_catalog SET name=?, kana=?, classification=?, category=?, default_unit=? WHERE id=?`
		if req.Classification == "èª¿å‘³æ–™" {
			req.Category = ""
			req.DefaultUnit = "g"
		}
		if _, err := tx.Exec(query, req.Name, req.Kana, req.Classification, req.Category, req.DefaultUnit, req.ID); err != nil {
			tx.Rollback()
			sendJSONError(w, "æ›´æ–°å¤±æ•—: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_export.go -----
package main

import (
	"encoding/csv"
	"fmt"
	"net/http"
	"time"
)

func exportCatalogCSV(w http.ResponseWriter, r *http.Request) {
	rows, err := db.Query("SELECT name, classification, category, default_unit, kana FROM item_catalog ORDER BY classification, name")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	fileName := fmt.Sprintf("catalog_export_%s.csv", time.Now().Format("20060102150405"))
	w.Header().Set("Content-Type", "text/csv")
	w.Header().Set("Content-Disposition", "attachment; filename=\""+fileName+"\"")

	writer := csv.NewWriter(w)
	defer writer.Flush()

	for rows.Next() {
		var name, classification, category, defaultUnit, kana NullString
		if err := rows.Scan(&name, &classification, &category, &defaultUnit, &kana); err != nil {
			http.Error(w, "è¡Œãƒ‡ãƒ¼ã‚¿ã®èª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
			return
		}
		record := []string{name.String, classification.String, category.String, defaultUnit.String, kana.String}
		if err := writer.Write(record); err != nil {
			http.Error(w, "CSVè¡Œã®æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
	if err := rows.Err(); err != nil {
		http.Error(w, "è¡Œã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
		return
	}
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_fridge_photos.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
)

func handleFridgePhotos(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getFridgePhotos(w, r)
	case "POST":
		addFridgePhoto(w, r)
	case "DELETE":
		deleteFridgePhoto(w, r)
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func getFridgePhotos(w http.ResponseWriter, _ *http.Request) {
	// location ã‚‚å–å¾—ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
	rows, err := db.Query("SELECT id, image_path, location, created_at FROM fridge_photos ORDER BY id DESC")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	photos := []FridgePhoto{}
	for rows.Next() {
		var p FridgePhoto
		var loc sql.NullString
		// location ã‚’ã‚¹ã‚­ãƒ£ãƒ³
		if err := rows.Scan(&p.ID, &p.ImagePath, &loc, &p.CreatedAt); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		p.Location = loc.String
		photos = append(photos, p)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(photos)
}

func addFridgePhoto(w http.ResponseWriter, r *http.Request) {
	var p FridgePhoto
	if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if p.ImagePath == "" {
		http.Error(w, "image_path required", http.StatusBadRequest)
		return
	}
	// å ´æ‰€ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€Œãã®ä»–ã€ã¨ã™ã‚‹
	if p.Location == "" {
		p.Location = "ãã®ä»–"
	}

	// location ã‚’DBã«ä¿å­˜
	res, err := db.Exec("INSERT INTO fridge_photos(image_path, location) VALUES(?, ?)", p.ImagePath, p.Location)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	id, _ := res.LastInsertId()
	p.ID = int(id)

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(p)
}

func deleteFridgePhoto(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}
	var id int
	fmt.Sscanf(idStr, "%d", &id)

	_, err := db.Exec("DELETE FROM fridge_photos WHERE id = ?", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_import.go -----
package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"io"
	"net/http"
	"strings"
)

type ImportResult struct {
	Added   int      `json:"added"`
	Skipped int      `json:"skipped"`
	Errors  []string `json:"errors,omitempty"`
}

func handleCatalogImport(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ", http.StatusBadRequest)
		return
	}
	r.Body.Close()

	if len(bodyBytes) >= 3 && bodyBytes[0] == 0xEF && bodyBytes[1] == 0xBB && bodyBytes[2] == 0xBF {
		bodyBytes = bodyBytes[3:]
	}

	reader := csv.NewReader(bytes.NewReader(bodyBytes))
	reader.FieldsPerRecord = -1

	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: "+err.Error(), http.StatusInternalServerError)
		return
	}

	checkStmt, err := tx.Prepare("SELECT id FROM item_catalog WHERE name = ?")
	if err != nil {
		tx.Rollback()
		http.Error(w, "DBæº–å‚™ã‚¨ãƒ©ãƒ¼: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer checkStmt.Close()

	insertStmt, err := tx.Prepare("INSERT INTO item_catalog (name, classification, category, default_unit, kana) VALUES (?, ?, ?, ?, ?)")
	if err != nil {
		tx.Rollback()
		http.Error(w, "DBæº–å‚™ã‚¨ãƒ©ãƒ¼: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer insertStmt.Close()

	result := ImportResult{}

	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			continue
		}
		if len(record) < 1 {
			continue
		}

		name := strings.TrimSpace(record[0])
		if name == "" {
			continue
		}

		classification := "é£Ÿæ"
		if len(record) > 1 {
			classification = strings.TrimSpace(record[1])
		}

		category := ""
		if len(record) > 2 {
			category = strings.TrimSpace(record[2])
		}

		unit := ""
		if len(record) > 3 {
			unit = strings.TrimSpace(record[3])
		}

		kana := ""
		if len(record) > 4 {
			kana = strings.TrimSpace(record[4])
		}

		if classification == "" {
			classification = "é£Ÿæ"
		}
		if classification == "èª¿å‘³æ–™" {
			category = ""
		}

		var existingID int
		err = checkStmt.QueryRow(name).Scan(&existingID)
		if err == nil {
			result.Skipped++
			continue
		}

		_, err = insertStmt.Exec(name, classification, category, unit, kana)
		if err != nil {
			result.Errors = append(result.Errors, name+": "+err.Error())
			continue
		}
		result.Added++
	}

	if err := tx.Commit(); err != nil {
		http.Error(w, "ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_ingredients.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
)

func handleIngredients(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getIngredients(w, r)
	case "POST":
		addIngredient(w, r)
	case "PUT":
		updateIngredient(w, r)
	case "DELETE":
		deleteIngredient(w, r)
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func getIngredients(w http.ResponseWriter, _ *http.Request) {
	const query = `
		SELECT
			i.id, i.catalog_id, i.amount, i.unit, i.expiration_date, i.location, 
			i.created_at, i.updated_at, c.name,
			(SELECT COUNT(DISTINCT recipe_id) FROM recipe_ingredients WHERE catalog_id = i.catalog_id) as recipe_count
		FROM refrigerator_ingredients i
		JOIN item_catalog c ON i.catalog_id = c.id
		LEFT JOIN locations l ON i.location = l.name
		ORDER BY 
			CASE WHEN l.priority IS NULL THEN 9999 ELSE l.priority END ASC,
			c.kana ASC,
			c.name ASC LIMIT 100;
	`
	rows, err := db.Query(query)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	items := []Ingredient{}
	for rows.Next() {
		var item Ingredient
		var loc sql.NullString

		if err := rows.Scan(&item.ID, &item.CatalogID, &item.Amount, &item.Unit, &item.ExpirationDate, &loc, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.RecipeCount); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		item.Location = loc.String
		items = append(items, item)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(items)
}

func addIngredient(w http.ResponseWriter, r *http.Request) {
	var item Ingredient
	if err := json.NewDecoder(r.Body).Decode(&item); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if item.CatalogID == 0 {
		http.Error(w, "catalog_id required", http.StatusBadRequest)
		return
	}
	if item.Location == "" {
		item.Location = "ãã®ä»–"
	}

	stmt, err := db.Prepare("INSERT INTO refrigerator_ingredients(catalog_id, amount, unit, expiration_date, location) VALUES(?, ?, ?, ?, ?)")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	res, err := stmt.Exec(item.CatalogID, item.Amount, item.Unit, item.ExpirationDate, item.Location)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	id, _ := res.LastInsertId()
	item.ID = int(id)

	w.WriteHeader(http.StatusCreated)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(item)
}

func updateIngredient(w http.ResponseWriter, r *http.Request) {
	var item Ingredient
	if err := json.NewDecoder(r.Body).Decode(&item); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if item.ID == 0 {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}

	_, err := db.Exec("UPDATE refrigerator_ingredients SET amount=?, expiration_date=?, location=?, updated_at=datetime('now','localtime') WHERE id=?", item.Amount, item.ExpirationDate, item.Location, item.ID)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "updated"})
}

func deleteIngredient(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}

	var id int
	fmt.Sscanf(idStr, "%d", &id)

	_, err := db.Exec("DELETE FROM refrigerator_ingredients WHERE id=?", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_locations.go -----
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// â˜…å‰Šé™¤: type Location struct ... ã®å®šç¾©ã‚’ã“ã“ã‹ã‚‰æ¶ˆå»ã—ã¾ã™
// ï¼ˆmodels.go ã«å®šç¾©æ¸ˆã¿ã®ãŸã‚ï¼‰

func handleLocations(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getLocations(w, r)
	case "POST":
		addLocation(w, r)
	case "PUT":
		reorderLocations(w, r)
	case "DELETE":
		deleteLocation(w, r)
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func getLocations(w http.ResponseWriter, _ *http.Request) {
	rows, err := db.Query("SELECT id, name, priority FROM locations ORDER BY priority ASC")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	locations := []Location{}
	for rows.Next() {
		var l Location
		if err := rows.Scan(&l.ID, &l.Name, &l.Priority); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		locations = append(locations, l)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(locations)
}

func addLocation(w http.ResponseWriter, r *http.Request) {
	var l Location
	if err := json.NewDecoder(r.Body).Decode(&l); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if l.Name == "" {
		http.Error(w, "name required", http.StatusBadRequest)
		return
	}

	var maxPriority int
	db.QueryRow("SELECT COALESCE(MAX(priority), 0) FROM locations").Scan(&maxPriority)

	res, err := db.Exec("INSERT INTO locations(name, priority) VALUES(?, ?)", l.Name, maxPriority+1)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	id, _ := res.LastInsertId()
	l.ID = int(id)
	l.Priority = maxPriority + 1

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(l)
}

func deleteLocation(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}
	var id int
	fmt.Sscanf(idStr, "%d", &id)

	_, err := db.Exec("DELETE FROM locations WHERE id = ?", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}

func reorderLocations(w http.ResponseWriter, r *http.Request) {
	var items []Location
	if err := json.NewDecoder(r.Body).Decode(&items); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	for i, item := range items {
		_, err := tx.Exec("UPDATE locations SET priority = ? WHERE id = ?", i+1, item.ID)
		if err != nil {
			tx.Rollback()
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	tx.Commit()
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_photos.go -----
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

func handleUpload(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	r.ParseMultipartForm(10 << 20)

	file, handler, err := r.FormFile("photo")
	if err != nil {
		http.Error(w, "ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", http.StatusBadRequest)
		return
	}
	defer file.Close()

	ext := filepath.Ext(handler.Filename)
	if ext == "" {
		ext = ".jpg"
	}
	filename := fmt.Sprintf("img_%d%s", time.Now().UnixNano(), ext)

	savePath := filepath.Join(DataDir, "images", filename)

	dst, err := os.Create(savePath)
	if err != nil {
		http.Error(w, "ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer dst.Close()

	if _, err := io.Copy(dst, file); err != nil {
		http.Error(w, "æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"status":   "success",
		"filename": filename,
	})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_recipes.go -----
package main

import (
	"bufio"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
)

type RecipeRequest struct {
	Name    string `json:"name"`
	Yield   string `json:"yield"`
	Process string `json:"process"`
	URL     string `json:"url"`
	CsvData string `json:"csv_data"`
}

type RecipeResponse struct {
	Recipe
	HasIngredients bool `json:"has_ingredients"`
	HasSeasonings  bool `json:"has_seasonings"`
}

func handleRecipes(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getRecipes(w, r)
	case "POST":
		addRecipe(w, r)
	case "PUT":
		updateRecipe(w, r)
	default:
		sendJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func sendJSONError(w http.ResponseWriter, message string, code int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(map[string]string{"error": message})
}

func sendMissingIngredientsError(w http.ResponseWriter, items []string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error_code": "missing_ingredients",
		"items":      items,
	})
}

func getRecipes(w http.ResponseWriter, r *http.Request) {
	// æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ãŒã‚ã‚‹å ´åˆã¨ãªã„å ´åˆã§ã‚¯ã‚¨ãƒªã‚’åˆ†å²ï¼ˆã“ã“ã¯æ—¢å­˜ã¨åŒã˜ï¼‰
	filterIngredientID := r.URL.Query().Get("ingredient_id")

	var rows *sql.Rows
	var err error
	if filterIngredientID != "" {
		// æ¤œç´¢æ™‚ã‚‚LIMITã‚’ã¤ã‘ã‚‹ã®ãŒå®‰å…¨
		query := `SELECT r.id, r.name, r.yield, r.process, r.url, r.created_at FROM recipes r JOIN recipe_ingredients ri ON r.id = ri.recipe_id WHERE ri.catalog_id = ? ORDER BY r.created_at DESC LIMIT 50`
		rows, err = db.Query(query, filterIngredientID)
	} else {
		// é€šå¸¸æ™‚
		query := `SELECT id, name, yield, process, url, created_at FROM recipes ORDER BY created_at DESC LIMIT 50`
		rows, err = db.Query(query)
	}
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	recipes := []RecipeResponse{}
	for rows.Next() {
		var r RecipeResponse
		var yield sql.NullString
		if err := rows.Scan(&r.ID, &r.Name, &yield, &r.Process, &r.URL, &r.CreatedAt); err != nil {
			continue
		}
		r.Yield = yield.String
		recipes = append(recipes, r)
	}

	// å–å¾—ä»¶æ•°ãŒ0ãªã‚‰ã“ã“ã§çµ‚äº†
	if len(recipes) == 0 {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(recipes)
		return
	}

	// --- é«˜é€ŸåŒ–ãƒã‚¤ãƒ³ãƒˆï¼šææ–™ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬å–å¾— ---

	// 1. ãƒ¬ã‚·ãƒ”IDã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‹
	recipeIDs := make([]interface{}, len(recipes))
	placeholders := make([]string, len(recipes))
	for i, r := range recipes {
		recipeIDs[i] = r.ID
		placeholders[i] = "?"
	}

	// 2. INå¥ã‚’ä½¿ã£ã¦ã€é–¢é€£ã™ã‚‹ææ–™ã‚’ä¸€æ’ƒã§å–å¾—ã™ã‚‹
	// "SELECT ... WHERE recipe_id IN (?, ?, ?, ...)"
	queryIng := fmt.Sprintf(`
		SELECT ri.recipe_id, ri.catalog_id, c.classification 
		FROM recipe_ingredients ri 
		JOIN item_catalog c ON ri.catalog_id = c.id 
		WHERE ri.recipe_id IN (%s)
	`, strings.Join(placeholders, ","))

	rowsIng, err := db.Query(queryIng, recipeIDs...)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rowsIng.Close()

	// 3. ãƒ¡ãƒ¢ãƒªä¸Šã§ã€Œãƒ¬ã‚·ãƒ”ID -> ææ–™ãƒªã‚¹ãƒˆã€ã®å¯¾å¿œè¡¨ã‚’ä½œã‚‹
	type IngInfo struct {
		CatalogID      int
		Classification string
	}
	recipeIngMap := make(map[int][]IngInfo)

	for rowsIng.Next() {
		var rID, cID int
		var cls string
		if err := rowsIng.Scan(&rID, &cID, &cls); err == nil {
			recipeIngMap[rID] = append(recipeIngMap[rID], IngInfo{CatalogID: cID, Classification: cls})
		}
	}

	// --- åœ¨åº«æƒ…å ±ã®å–å¾— (ã“ã‚Œã¯1å›ã§æ¸ˆã‚€ã®ã§ãã®ã¾ã¾ã§OK) ---
	invMap := make(map[int]bool)
	rowsInv, _ := db.Query("SELECT catalog_id FROM refrigerator_ingredients")
	if rowsInv != nil {
		for rowsInv.Next() {
			var cid int
			rowsInv.Scan(&cid)
			invMap[cid] = true
		}
		rowsInv.Close()
	}

	seasMap := make(map[int]bool)
	rowsSeas, _ := db.Query("SELECT catalog_id FROM refrigerator_seasonings WHERE status != 'ãªã—'")
	if rowsSeas != nil {
		for rowsSeas.Next() {
			var cid int
			rowsSeas.Scan(&cid)
			seasMap[cid] = true
		}
		rowsSeas.Close()
	}

	// --- åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (ãƒ¡ãƒ¢ãƒªä¸Šã®ãƒãƒƒãƒ—ã‚’è¦‹ã‚‹ã ã‘ãªã®ã§çˆ†é€Ÿ) ---
	for i := range recipes {
		hasIng := true
		hasSeas := true

		// DBã‚¢ã‚¯ã‚»ã‚¹ã§ã¯ãªãã€ã•ã£ãä½œã£ãŸãƒãƒƒãƒ—ã‚’è¦‹ã‚‹
		ingredients := recipeIngMap[recipes[i].ID]

		for _, ing := range ingredients {
			if ing.Classification == "èª¿å‘³æ–™" {
				if !seasMap[ing.CatalogID] {
					hasSeas = false
				}
			} else {
				if !invMap[ing.CatalogID] {
					hasIng = false
				}
			}
		}
		recipes[i].HasIngredients = hasIng
		recipes[i].HasSeasonings = hasSeas
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(recipes)
}

func addRecipe(w http.ResponseWriter, r *http.Request) {
	saveRecipeCommon(w, r, 0)
}

func updateRecipe(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		sendJSONError(w, "ID required", http.StatusBadRequest)
		return
	}
	var id int
	fmt.Sscanf(idStr, "%d", &id)
	saveRecipeCommon(w, r, id)
}
func saveRecipeCommon(w http.ResponseWriter, r *http.Request, id int) {
	var req RecipeRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendJSONError(w, err.Error(), http.StatusBadRequest)
		return
	}
	if req.Name == "" {
		sendJSONError(w, "ãƒ¬ã‚·ãƒ”åã¯å¿…é ˆã§ã™", http.StatusBadRequest)
		return
	}

	type parsedIng struct {
		CatalogID int
		Unit      string
		Amount    string
		GroupName string
	}
	var ingredients []parsedIng
	var unknownItems []string

	tx, err := db.Begin()
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// â˜…ä¿®æ­£ç®‡æ‰€: ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’æ”¹è¡Œã‚³ãƒ¼ãƒ‰ã«ç½®æ›ã—ã€è§£æã‚’å®¹æ˜“ã«ã™ã‚‹
	csvDataProcessed := strings.ReplaceAll(req.CsvData, "/", "\n")

	scanner := bufio.NewScanner(strings.NewReader(csvDataProcessed))
	var currentGroup string

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		if strings.HasPrefix(line, "=") || strings.HasPrefix(line, "ï¼") {
			currentGroup = strings.Trim(line, "=ï¼ \tã€€")
			continue
		}

		var name, amount, unit string

		if strings.Contains(line, "â€¦") {
			parts := strings.SplitN(line, "â€¦", 2)
			name = strings.TrimSpace(parts[0])
			if len(parts) > 1 {
				amount = strings.TrimSpace(parts[1])
			}
		} else if strings.Contains(line, "...") {
			parts := strings.SplitN(line, "...", 2)
			name = strings.TrimSpace(parts[0])
			if len(parts) > 1 {
				amount = strings.TrimSpace(parts[1])
			}
		} else if strings.Contains(line, ",") {
			parts := strings.Split(line, ",")
			name = strings.TrimSpace(parts[0])
			if len(parts) > 1 {
				amount = strings.TrimSpace(parts[1])
			}
			if len(parts) > 2 {
				unit = strings.TrimSpace(parts[2])
			}
		} else {
			name = line
		}

		if name == "" {
			continue
		}

		var catalogID int
		err = tx.QueryRow("SELECT id FROM item_catalog WHERE name = ? OR kana = ?", name, name).Scan(&catalogID)
		if err != nil {
			unknownItems = append(unknownItems, name)
			continue
		}

		ingredients = append(ingredients, parsedIng{
			CatalogID: catalogID,
			Unit:      unit,
			Amount:    amount,
			GroupName: currentGroup,
		})
	}

	if len(unknownItems) > 0 {
		tx.Rollback()
		sendMissingIngredientsError(w, unknownItems)
		return
	}

	if id == 0 {
		res, err := tx.Exec("INSERT INTO recipes(name, yield, process, url) VALUES(?, ?, ?, ?)", req.Name, req.Yield, req.Process, req.URL)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		newID, _ := res.LastInsertId()
		id = int(newID)
	} else {
		_, err := tx.Exec("UPDATE recipes SET name=?, yield=?, process=?, url=? WHERE id=?", req.Name, req.Yield, req.Process, req.URL, id)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		_, err = tx.Exec("DELETE FROM recipe_ingredients WHERE recipe_id=?", id)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	ingStmt, err := tx.Prepare("INSERT INTO recipe_ingredients(recipe_id, catalog_id, unit, amount, group_name) VALUES(?, ?, ?, ?, ?)")
	if err != nil {
		tx.Rollback()
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer ingStmt.Close()

	for _, ing := range ingredients {
		if _, err := ingStmt.Exec(id, ing.CatalogID, ing.Unit, ing.Amount, ing.GroupName); err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func handleRecipeIngredients(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		sendJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	recipeID := r.URL.Query().Get("id")
	if recipeID == "" {
		sendJSONError(w, "id is required", http.StatusBadRequest)
		return
	}

	query := `
		SELECT 
			c.name, 
			ri.amount, 
			ri.unit,
			ri.group_name,
			CASE 
				WHEN c.classification = 'èª¿å‘³æ–™' THEN 
					(SELECT COUNT(*) FROM refrigerator_seasonings WHERE catalog_id = c.id AND status != 'ãªã—')
				ELSE 
					(SELECT COUNT(*) FROM refrigerator_ingredients WHERE catalog_id = c.id)
			END as stock_count
		FROM recipe_ingredients ri
		JOIN item_catalog c ON ri.catalog_id = c.id
		WHERE ri.recipe_id = ?
	`

	rows, err := db.Query(query, recipeID)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	type ResIngredient struct {
		Name      string `json:"name"`
		Amount    string `json:"amount"`
		Unit      string `json:"unit"`
		GroupName string `json:"group_name"`
		InStock   bool   `json:"in_stock"`
	}

	var ingredients []ResIngredient
	for rows.Next() {
		var i ResIngredient
		var stockCount int
		var gn sql.NullString
		if err := rows.Scan(&i.Name, &i.Amount, &i.Unit, &gn, &stockCount); err != nil {
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		i.GroupName = gn.String
		i.InStock = (stockCount > 0)
		ingredients = append(ingredients, i)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(ingredients)
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_seasonings.go -----
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

func handleSeasonings(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getSeasonings(w, r)
	case "POST":
		addSeasoning(w, r)
	case "DELETE":
		deleteSeasoning(w, r)
	default:
		http.Error(w, "ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚", http.StatusMethodNotAllowed)
	}
}

func getSeasonings(w http.ResponseWriter, _ *http.Request) {
	const query = `
		SELECT
			s.id, s.catalog_id, s.status, s.created_at, s.updated_at,
			c.name, c.classification, c.category
		FROM refrigerator_seasonings s
		JOIN item_catalog c ON s.catalog_id = c.id
		ORDER BY c.kana ASC, c.name ASC; 
` // â˜…ä¿®æ­£: kanaé †ã‚’å„ªå…ˆ
	rows, err := db.Query(query)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	items := []Seasoning{}
	for rows.Next() {
		var item Seasoning
		if err := rows.Scan(
			&item.ID, &item.CatalogID, &item.Status, &item.CreatedAt, &item.UpdatedAt,
			&item.Name, &item.Classification, &item.Category,
		); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		items = append(items, item)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(items)
}

func addSeasoning(w http.ResponseWriter, r *http.Request) {
	var item Seasoning
	if err := json.NewDecoder(r.Body).Decode(&item); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if item.CatalogID == 0 {
		http.Error(w, "catalog_idã¯å¿…é ˆã§ã™", http.StatusBadRequest)
		return
	}
	if item.Status == "" {
		item.Status = "ã‚ã‚Š"
	}

	stmt, err := db.Prepare("INSERT INTO refrigerator_seasonings(catalog_id, status) VALUES(?, ?)")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	res, err := stmt.Exec(item.CatalogID, item.Status)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	id, _ := res.LastInsertId()
	item.ID = int(id)

	w.WriteHeader(http.StatusCreated)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(item)
}

func deleteSeasoning(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}

	var id int
	fmt.Sscanf(idStr, "%d", &id)

	_, err := db.Exec("DELETE FROM refrigerator_seasonings WHERE id=?", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\main.go -----
package main

import (
	"database/sql"
	"embed"
	"fmt"
	"io/fs"
	"log"
	"net/http"
	"os"
	"path/filepath"

	_ "github.com/mattn/go-sqlite3"
)

//go:embed static/*
var staticFiles embed.FS

var DataDir string

func main() {
	currentDir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	// â˜…å¤‰æ›´: "data" ãƒ•ã‚©ãƒ«ãƒ€ã®ä¸­ã«ä¿å­˜ã™ã‚‹ã‚ˆã†ã«æ›¸ãæ›ãˆã‚‹
	DataDir = filepath.Join(currentDir, "data")

	// â˜…è¿½åŠ : dataãƒ•ã‚©ãƒ«ãƒ€ãŒãªã‘ã‚Œã°ä½œã‚‹
	if err := os.MkdirAll(DataDir, 0755); err != nil {
		log.Fatal(err)
	}

	imagesPath := filepath.Join(DataDir, "images")
	if err := os.MkdirAll(imagesPath, 0755); err != nil {
		log.Fatal(err)
	}

	dbPath := filepath.Join(DataDir, "kimichan.db")
	db, err = sql.Open("sqlite3", dbPath)
	if err != nil {
		log.Fatalf("DB connection failed: %v", err)
	}
	defer db.Close()

	if err := initDatabase(); err != nil {
		log.Fatalf("DB init failed: %v", err)
	}

	mux := http.NewServeMux()

	mux.HandleFunc("/api/catalog", handleCatalog)
	mux.HandleFunc("/api/catalog/usage", handleCatalogUsage) // è¿½åŠ 
	mux.HandleFunc("/api/catalog/export", exportCatalogCSV)
	mux.HandleFunc("/api/ingredients", handleIngredients)
	mux.HandleFunc("/api/seasonings", handleSeasonings)
	mux.HandleFunc("/api/recipes", handleRecipes)
	mux.HandleFunc("/api/recipes/ingredients", handleRecipeIngredients)
	mux.HandleFunc("/api/locations", handleLocations)
	mux.HandleFunc("/import/catalog", handleCatalogImport)
	mux.HandleFunc("/api/upload", handleUpload)
	mux.HandleFunc("/api/fridge_photos", handleFridgePhotos)

	mux.Handle("/images/", http.StripPrefix("/images/", http.FileServer(http.Dir(imagesPath))))

	staticFS, _ := fs.Sub(staticFiles, "static")
	mux.Handle("/", http.FileServer(http.FS(staticFS)))

	fmt.Println("Server is running at http://localhost:8080")
	if err := http.ListenAndServe(":8080", basicAuth(mux)); err != nil {
		log.Fatal(err)
	}
}

// Basicèªè¨¼ã‚’è¡Œã†ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
func basicAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// â–¼â–¼ ã“ã“ã§IDã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ±ºã‚ã¾ã™ â–¼â–¼
		const expectedUser = "wasabi"
		const expectedPass = "karashi"
		// â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

		user, pass, ok := r.BasicAuth()
		if !ok || user != expectedUser || pass != expectedPass {
			w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}
		next.ServeHTTP(w, r)
	})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\models.go -----
package main

import (
	"database/sql"
	"encoding/json"
)

type CatalogItem struct {
	ID             int    `json:"id"`
	Name           string `json:"name"`
	Kana           string `json:"kana"`
	Classification string `json:"classification"`
	Category       string `json:"category"`
	DefaultUnit    string `json:"default_unit"`
}

type Ingredient struct {
	ID             int     `json:"id"`
	CatalogID      int     `json:"catalog_id"`
	Amount         float64 `json:"amount"`
	Unit           string  `json:"unit"`
	ExpirationDate string  `json:"expiration_date"`
	Location       string  `json:"location"`
	CreatedAt      string  `json:"created_at"`
	UpdatedAt      string  `json:"updated_at"`
	Name           string  `json:"name,omitempty"`
	RecipeCount    int     `json:"recipe_count"`
}

type Seasoning struct {
	ID             int    `json:"id"`
	CatalogID      int    `json:"catalog_id"`
	Status         string `json:"status"`
	CreatedAt      string `json:"created_at"`
	UpdatedAt      string `json:"updated_at"`
	Name           string `json:"name,omitempty"`
	Classification string `json:"classification,omitempty"`
	Category       string `json:"category,omitempty"`
}

type Recipe struct {
	ID          int                `json:"id"`
	Name        string             `json:"name"`
	Yield       string             `json:"yield"`
	Process     string             `json:"process"`
	URL         string             `json:"url"`
	SourceType  string             `json:"source_type"`
	CreatedAt   string             `json:"created_at"`
	Ingredients []RecipeIngredient `json:"ingredients,omitempty"`
}

type RecipeIngredient struct {
	ID        int    `json:"id"`
	RecipeID  int    `json:"recipe_id"`
	CatalogID int    `json:"catalog_id"`
	Name      string `json:"name"`
	Quantity  string `json:"quantity"`
	GroupName string `json:"group_name"`
}

type FridgePhoto struct {
	ID        int    `json:"id"`
	ImagePath string `json:"image_path"`
	Location  string `json:"location"` // è¿½åŠ 
	CreatedAt string `json:"created_at"`
}

type Location struct {
	ID       int    `json:"id"`
	Name     string `json:"name"`
	Priority int    `json:"priority"`
}

type NullString struct {
	sql.NullString
}

func (ns *NullString) Scan(value interface{}) error {
	return ns.NullString.Scan(value)
}

func (ns NullString) MarshalJSON() ([]byte, error) {
	if ns.Valid {
		return json.Marshal(ns.String)
	}
	return json.Marshal(nil)
}


