----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\cleaner\main.go -----
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"time"

	"kimichan/tools/common" // â˜…å…±é€šéƒ¨å“
)

type CleaningResult struct {
	BaseName string `json:"base_name"`
	Details  string `json:"details"`
	IsSplit  bool   `json:"is_split"`
}

func main() {
	cfg, err := common.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}

	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸ§¹ ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆèµ·å‹•...")

	rows, _ := db.Query("SELECT id, name FROM item_catalog")
	defer rows.Close()

	for rows.Next() {
		var id int
		var name string
		rows.Scan(&id, &name)

		// ãƒã‚§ãƒƒã‚¯ï¼†Geminiå‘¼ã³å‡ºã—
		prompt := fmt.Sprintf("é£Ÿæã€Œ%sã€ã‚’ä¸€èˆ¬åã¨è©³ç´°ã«åˆ†é›¢ã—ã¦JSONå‡ºåŠ›(base_name, details, is_split)", name)
		resStr, err := common.CallGemini(prompt, cfg.GeminiApiKey)

		if err == nil {
			var res CleaningResult
			if json.Unmarshal([]byte(resStr), &res) == nil && res.IsSplit {
				fmt.Printf("ä¿®æ­£: %s -> %s (%s)\n", name, res.BaseName, res.Details)
				// ã“ã“ã«DBæ›´æ–°å‡¦ç† (executeSplit)
			}
		}
		time.Sleep(1 * time.Second)
	}
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\common\common.go -----
package common

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
const CONFIG_FILE = "config.json"

type Config struct {
	GeminiApiKey string `json:"gemini_api_key"`
}

// Geminiã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ§‹é€ ä½“
type GeminiRequest struct {
	Contents []Content `json:"contents"`
}
type Content struct {
	Parts []Part `json:"parts"`
}
type Part struct {
	Text string `json:"text"`
}
type GeminiResponse struct {
	Candidates []struct {
		Content struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		} `json:"content"`
	} `json:"candidates"`
}

// --- å…±é€šé–¢æ•° ---

// è¨­å®šã‚’èª­ã¿è¾¼ã‚€
func LoadConfig() (*Config, error) {
	// è¦ªãƒ•ã‚©ãƒ«ãƒ€ãªã©ã‚‚æ¢ã™
	wd, _ := os.Getwd()
	paths := []string{
		filepath.Join(wd, CONFIG_FILE),
		filepath.Join(wd, "..", CONFIG_FILE),
		filepath.Join(wd, "..", "..", CONFIG_FILE),
	}

	for _, p := range paths {
		if _, err := os.Stat(p); err == nil {
			file, err := os.Open(p)
			if err != nil {
				return nil, err
			}
			defer file.Close()
			var cfg Config
			if err := json.NewDecoder(file).Decode(&cfg); err == nil {
				return &cfg, nil
			}
		}
	}
	return nil, fmt.Errorf("config.json ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
}

// DBã«æ¥ç¶šã™ã‚‹
func ConnectDB() (*sql.DB, error) {
	wd, _ := os.Getwd()

	// â˜…å¤‰æ›´: dataãƒ•ã‚©ãƒ«ãƒ€ã®ä¸­ã‚’å„ªå…ˆçš„ã«æ¢ã™ã‚ˆã†ã«å¤‰æ›´
	paths := []string{
		filepath.Join(wd, "data", "kimichan.db"),             // tools/common/data/kimichan.db (ç¨€)
		filepath.Join(wd, "kimichan.db"),                     // ã‚«ãƒ¬ãƒ³ãƒˆ (æ—§)
		filepath.Join(wd, "..", "data", "kimichan.db"),       // tools/data/kimichan.db
		filepath.Join(wd, "..", "..", "data", "kimichan.db"), // kimichan2/data/kimichan.db (â˜…æœ¬å‘½)
	}

	var dbPath string
	for _, p := range paths {
		// ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãŒãªãã¦ã‚‚ãƒ•ã‚©ãƒ«ãƒ€ãŒã‚ã‚Œã°OKã¨ã™ã‚‹ï¼‰
		dir := filepath.Dir(p)
		if _, err := os.Stat(dir); err == nil {
			dbPath = p
			break
		}
	}

	if dbPath == "" {
		// è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã‚«ãƒ¬ãƒ³ãƒˆã®dataãƒ•ã‚©ãƒ«ãƒ€ã‚’æŒ‡å®š
		dbPath = filepath.Join("data", "kimichan.db")
		os.MkdirAll("data", 0755) // å¿µã®ãŸã‚ä½œæˆ
	}

	return sql.Open("sqlite3", dbPath)
}

// Geminiã‚’å‘¼ã³å‡ºã™
func CallGemini(prompt string, apiKey string) (string, error) {
	url := "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + apiKey
	reqBody, _ := json.Marshal(GeminiRequest{Contents: []Content{{Parts: []Part{{Text: prompt}}}}})

	for i := 0; i < 3; i++ {
		resp, err := http.Post(url, "application/json", bytes.NewBuffer(reqBody))
		if err != nil {
			return "", err
		}
		defer resp.Body.Close()

		body, _ := io.ReadAll(resp.Body)
		if resp.StatusCode == 200 {
			var geminiResp GeminiResponse
			json.Unmarshal(body, &geminiResp)
			if len(geminiResp.Candidates) == 0 {
				return "", fmt.Errorf("å¿œç­”ãªã—")
			}
			txt := geminiResp.Candidates[0].Content.Parts[0].Text

			// JSONåˆ‡ã‚Šå‡ºã—
			start := strings.Index(txt, "{")
			if start == -1 {
				start = strings.Index(txt, "[")
			} // é…åˆ—ã®å ´åˆã‚‚è€ƒæ…®

			end := strings.LastIndex(txt, "}")
			if end == -1 {
				end = strings.LastIndex(txt, "]")
			}

			if start != -1 && end != -1 {
				return txt[start : end+1], nil
			}
			return "", fmt.Errorf("JSONãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		}
		if resp.StatusCode == 503 {
			time.Sleep(3 * time.Second)
			continue
		}
		return "", fmt.Errorf("API Error: %s", resp.Status)
	}
	return "", fmt.Errorf("ãƒªãƒˆãƒ©ã‚¤ä¸Šé™")
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\garbage_collector\main.go -----
package main

import (
	"fmt"
	"log"

	"kimichan/tools/common"
)

func main() {
	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸ—‘ï¸ ã‚´ãƒŸæ¨ã¦ãƒ­ãƒœãƒƒãƒˆï¼ˆæœªä½¿ç”¨é£Ÿæã®å‰Šé™¤ï¼‰ã€èµ·å‹•ã—ã¾ã™...")

	// ã©ã®ãƒ¬ã‚·ãƒ”ã«ã‚‚ã€ã©ã®åœ¨åº«ã«ã‚‚ä½¿ã‚ã‚Œã¦ã„ãªã„é£Ÿæã‚’æ¢ã—ã¦å‰Šé™¤
	// (SQLiteã¯ DELETE JOIN ãŒä½¿ãˆãªã„ã®ã§ã‚µãƒ–ã‚¯ã‚¨ãƒªã§)
	query := `
		DELETE FROM item_catalog 
		WHERE id NOT IN (SELECT DISTINCT catalog_id FROM recipe_ingredients) 
		  AND id NOT IN (SELECT DISTINCT catalog_id FROM refrigerator_ingredients)
		  AND id NOT IN (SELECT DISTINCT catalog_id FROM refrigerator_seasonings)
	`

	res, err := db.Exec(query)
	if err != nil {
		log.Fatal("å‰Šé™¤ã‚¨ãƒ©ãƒ¼:", err)
	}

	count, _ := res.RowsAffected()
	fmt.Printf("âœ¨ ã‚¹ãƒƒã‚­ãƒªï¼ %d ä»¶ã®æœªä½¿ç”¨é£Ÿæã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚\n", count)
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\generator\main.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"
	"unicode/utf8"

	"kimichan/tools/common"

	"github.com/PuerkitoBio/goquery"
	_ "github.com/mattn/go-sqlite3"
)

const TARGET_URL = "https://bazurecipe.com/"
const LIMIT_TOTAL = 100
const LIMIT_PER_PAGE = 10
const STATE_FILE = "generator_state.txt"

type LinkAnalysisResult struct {
	RecipeLinks []string `json:"recipe_links"`
	NextPageURL string   `json:"next_page_url"`
}

type GeneratedRecipe struct {
	Name        string `json:"name"`
	Yield       string `json:"yield"`
	Ingredients []struct {
		Name    string `json:"name"`
		Amount  string `json:"amount"`  // å˜ä½è¾¼ã¿
		Details string `json:"details"` // è¿½åŠ : è©³ç´°æƒ…å ±
	} `json:"ingredients"`
	Process        any    `json:"process"`
	RawIngredients string `json:"raw_ingredients"`
	RawProcess     string `json:"raw_process"`
}

var apiKey string

func main() {
	cfg, err := common.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}
	apiKey = cfg.GeminiApiKey

	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸ¤– ãƒ¬ã‚·ãƒ”åé›†ãƒ­ãƒœãƒƒãƒˆ (3åˆ—ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå¯¾å¿œç‰ˆ)ã€èµ·å‹•...")

	currentURL := TARGET_URL
	totalCollected := 0

	for {
		if totalCollected >= LIMIT_TOTAL {
			break
		}
		fmt.Printf("\nğŸ“„ ãƒšãƒ¼ã‚¸è§£æä¸­... [%s]\n", currentURL)

		htmlText, err := fetchHTML(currentURL)
		if err != nil {
			log.Println("å–å¾—ã‚¨ãƒ©ãƒ¼:", err)
			break
		}

		analysis, err := askGeminiForLinksAndNext(htmlText, currentURL)
		if err != nil {
			log.Println("è§£æã‚¨ãƒ©ãƒ¼:", err)
			break
		}

		links := analysis.RecipeLinks
		if len(links) > LIMIT_PER_PAGE {
			links = links[:LIMIT_PER_PAGE]
		}
		fmt.Printf("ğŸ“¦ ç™ºè¦‹: %d ä»¶ / æ¬¡ã¸: %s\n", len(links), analysis.NextPageURL)

		for _, link := range links {
			if totalCollected >= LIMIT_TOTAL {
				break
			}
			fmt.Printf("  ğŸ³ è§£æä¸­: %s ...\n", link)

			detailHTML, err := fetchHTML(link)
			if err == nil {
				recipe, err := analyzeByGemini(detailHTML)
				if err == nil {
					// ä¿å­˜
					if err := saveRecipe(db, recipe, link); err != nil {
						fmt.Printf("    âŒ ä¿å­˜ã‚¨ãƒ©ãƒ¼: %v\n", err)
					} else {
						totalCollected++
					}
				} else {
					fmt.Printf("    âŒ AIè§£æå¤±æ•—: %v\n", err)
				}
			}
			time.Sleep(2 * time.Second)
		}

		if analysis.NextPageURL != "" && analysis.NextPageURL != currentURL {
			currentURL = analysis.NextPageURL
		} else {
			break
		}
	}
	fmt.Println("\nâœ¨ å®Œäº†ã—ã¾ã—ãŸï¼")
}

func fetchHTML(url string) (string, error) {
	client := &http.Client{Timeout: 30 * time.Second}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return "", err
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return "", err
	}
	doc.Find("script, style, nav, footer, iframe, svg").Remove()
	return doc.Find("body").Text(), nil
}

func askGeminiForLinksAndNext(text, baseURL string) (*LinkAnalysisResult, error) {
	if len(text) > 50000 {
		text = text[:50000]
	}
	prompt := fmt.Sprintf(`ä»¥ä¸‹ã‹ã‚‰ãƒ¬ã‚·ãƒ”è©³ç´°URLã¨æ¬¡ãƒšãƒ¼ã‚¸URLã‚’JSONæŠ½å‡ºã€‚JSONã®ã¿å‡ºåŠ›ã€‚
1. "recipe_links": URLãƒªã‚¹ãƒˆ
2. "next_page_url": æ¬¡ãƒšãƒ¼ã‚¸URL(ãªã‘ã‚Œã°ç©ºæ–‡å­—)
BaseURL: %s
Text: %s`, baseURL, text)

	resStr, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, err
	}
	var res LinkAnalysisResult
	if err := json.Unmarshal([]byte(resStr), &res); err != nil {
		return nil, fmt.Errorf("jsonè§£æå¤±æ•—: %v", err)
	}
	return &res, nil
}

func analyzeByGemini(text string) (*GeneratedRecipe, error) {
	if len(text) > 40000 {
		text = text[:40000]
	}
	// â˜…ä¿®æ­£: amountã«å˜ä½ã‚’å«ã‚ã‚‹ã“ã¨ã€detailsã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ã‚’æŒ‡ç¤º
	prompt := `ãƒ¬ã‚·ãƒ”æƒ…å ±ã‚’JSONæŠ½å‡ºã€‚JSONã®ã¿å‡ºåŠ›ã€‚
keys: 
- name
- yield
- ingredients [{name, amount(å˜ä½è¾¼ã¿ã®åˆ†é‡æ–‡å­—åˆ—), details(è£œè¶³æƒ…å ±)}]
- raw_ingredients (ææ–™ãƒªã‚¹ãƒˆã®åŸæ–‡ãã®ã¾ã¾ã®ãƒ†ã‚­ã‚¹ãƒˆ)
- process (æ‰‹é †ã®é…åˆ—)
- raw_process (æ‰‹é †ã®åŸæ–‡ãã®ã¾ã¾ã®ãƒ†ã‚­ã‚¹ãƒˆ)

Text: ` + text

	resStr, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, err
	}
	var r GeneratedRecipe
	if err := json.Unmarshal([]byte(resStr), &r); err != nil {
		return nil, fmt.Errorf("jsonè§£æå¤±æ•—: %v", err)
	}
	return &r, nil
}

func saveRecipe(db *sql.DB, r *GeneratedRecipe, sourceURL string) error {
	if r == nil || r.Name == "" {
		return fmt.Errorf("ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™")
	}

	var exists int
	err := db.QueryRow("SELECT count(*) FROM recipes WHERE name = ?", r.Name).Scan(&exists)
	if err != nil {
		return fmt.Errorf("dbæ¤œç´¢ã‚¨ãƒ©ãƒ¼: %v", err)
	}
	if exists > 0 {
		fmt.Printf("    âš ï¸ ç™»éŒ²æ¸ˆã¿: %s\n", r.Name)
		return nil
	}

	var processText string
	if r.Process != nil {
		switch v := r.Process.(type) {
		case string:
			processText = v
		case []interface{}:
			var lines []string
			for _, line := range v {
				if str, ok := line.(string); ok {
					lines = append(lines, str)
				}
			}
			processText = strings.Join(lines, "\n")
		default:
			processText = fmt.Sprintf("%v", v)
		}
	}

	if r.RawProcess == "" {
		r.RawProcess = processText
	}
	if r.RawIngredients == "" {
		b, _ := json.Marshal(r.Ingredients)
		r.RawIngredients = string(b)
	}

	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("txé–‹å§‹ã‚¨ãƒ©ãƒ¼: %v", err)
	}

	res, err := tx.Exec("INSERT INTO recipes(name, yield, process, original_ingredients, original_process, url) VALUES(?, ?, ?, ?, ?, ?)",
		r.Name, r.Yield, processText, r.RawIngredients, r.RawProcess, sourceURL)
	if err != nil {
		tx.Rollback()
		return fmt.Errorf("ãƒ¬ã‚·ãƒ”ä¿å­˜ã‚¨ãƒ©ãƒ¼: %v", err)
	}
	recipeID, _ := res.LastInsertId()

	for _, ing := range r.Ingredients {
		if ing.Name == "" {
			continue
		}
		if utf8.RuneCountInString(ing.Name) > 15 || strings.Contains(ing.Name, "å‘³å¤‰") || strings.Contains(ing.Name, "ãŠå¥½ã¿") {
			continue
		}

		var catalogID int
		db.QueryRow("SELECT id FROM item_catalog WHERE name = ?", ing.Name).Scan(&catalogID)

		if catalogID == 0 {
			res, err := tx.Exec("INSERT INTO item_catalog(name, classification, category, default_unit) VALUES(?, ?, ?, ?)",
				ing.Name, "é£Ÿæ", "æœªåˆ†é¡", "")
			if err != nil {
				continue
			}
			newID, _ := res.LastInsertId()
			catalogID = int(newID)
		}

		// â˜…ä¿®æ­£: unitã¯ç©ºæ–‡å­—ã€amountã«å˜ä½è¾¼ã¿ã®åˆ†é‡ã€detailsã‚’ä¿å­˜
		tx.Exec("INSERT INTO recipe_ingredients(recipe_id, catalog_id, unit, amount, group_name, details) VALUES(?, ?, ?, ?, ?, ?)",
			recipeID, catalogID, "", ing.Amount, "", ing.Details)
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("ã‚³ãƒŸãƒƒãƒˆã‚¨ãƒ©ãƒ¼: %v", err)
	}
	fmt.Printf("    âœ… ä¿å­˜å®Œäº†: %s\n", r.Name)
	return nil
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\manual_importer\main.go -----
package main

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/tabwriter"

	"kimichan/tools/common"
)

const INPUT_FILE = "manual_input.txt"
const SUBST_FILE = "substitutions.csv"

type GeneratedRecipe struct {
	Name        string `json:"name"`
	Yield       string `json:"yield"`
	Ingredients []struct {
		Name    string `json:"name"`
		Amount  string `json:"amount"` // å˜ä½è¾¼ã¿
		Group   string `json:"group"`
		Details string `json:"details"` // è©³ç´°æƒ…å ±
	} `json:"ingredients"`
	Process        any    `json:"process"`
	RawIngredients string `json:"raw_ingredients"`
	RawProcess     string `json:"raw_process"`
}

// AIã®åå¯„ã›çµæœ
type NormalizeResult struct {
	StandardName string `json:"standard_name"`
	Kana         string `json:"kana"`
	Details      string `json:"details"`
}

// å¼·åˆ¶å¤‰æ›ãƒ«ãƒ¼ãƒ«
type Substitution struct {
	TargetName string
	Details    string
}

var apiKey string
var nameSubstitutions map[string]Substitution

func main() {
	// è¨­å®šèª­ã¿è¾¼ã¿
	cfg, err := common.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}
	apiKey = cfg.GeminiApiKey

	// è¾æ›¸èª­ã¿è¾¼ã¿
	loadSubstitutions()

	// DBæ¥ç¶š
	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸ“ æ‰‹å‹•ãƒ¬ã‚·ãƒ”å–è¾¼ãƒ­ãƒœãƒƒãƒˆ (3åˆ—ãƒ»è¾æ›¸ãƒ»ãƒ¨ãƒŸã‚¬ãƒŠè‡ªå‹•ä»˜ä¸ç‰ˆ)ã€èµ·å‹•...")

	// ãƒ†ãƒ¼ãƒ–ãƒ«ãŒãªã‘ã‚Œã°ä½œæˆã™ã‚‹
	fixDatabaseSchema(db)

	wd, _ := os.Getwd()
	inputPath := filepath.Join(wd, INPUT_FILE)
	if _, err := os.Stat(inputPath); os.IsNotExist(err) {
		inputPath = filepath.Join(wd, "..", "..", INPUT_FILE)
	}

	contentBytes, err := os.ReadFile(inputPath)
	if err != nil {
		log.Fatalf("âŒ å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«(%s)ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", INPUT_FILE)
	}
	content := string(contentBytes)
	if strings.TrimSpace(content) == "" {
		log.Fatal("âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã£ã½ã§ã™")
	}

	fmt.Println("ğŸ” ãƒ†ã‚­ã‚¹ãƒˆè§£æä¸­...")

	recipes, rawResp, err := analyzeManualText(content, apiKey)
	if err != nil {
		log.Println("âŒ AIè§£æã‚¨ãƒ©ãƒ¼:", err)
		fmt.Println(rawResp)
		return
	}

	fmt.Printf("ğŸ“¦ %d ä»¶ã®ãƒ¬ã‚·ãƒ”ã‚’æ¤œå‡ºã€‚\n", len(recipes))

	for i, r := range recipes {
		// è¡¨ç¤ºã‚„ä¿å­˜ã®å‰ã«å¼·åˆ¶å¤‰æ›ã‚’é©ç”¨ã™ã‚‹
		applySubstitutions(&r)

		fmt.Printf("\n[%d/%d] %s\n", i+1, len(recipes), r.Name)
		printComparison(&r)
		saveRecipe(db, &r, "æ‰‹å‹•å…¥åŠ›")
	}

	fmt.Println("\nâœ¨ å®Œäº†ã—ã¾ã—ãŸï¼")
	os.WriteFile(inputPath, []byte(""), 0644)
}

func loadSubstitutions() {
	nameSubstitutions = make(map[string]Substitution)

	// â˜…ä¿®æ­£: æ¢ç´¢ãƒ‘ã‚¹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¢—ã‚„ã—ã¾ã—ãŸ
	// 1. ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (tools/manual_importerã§å®Ÿè¡Œæ™‚)
	// 2. tools/manual_importer/ (ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã§å®Ÿè¡Œæ™‚)
	// 3. ../../ (å¿µã®ãŸã‚)
	candidates := []string{
		SUBST_FILE,
		filepath.Join("tools", "manual_importer", SUBST_FILE),
		filepath.Join("..", "..", SUBST_FILE),
	}

	var file *os.File
	var err error
	var foundPath string

	for _, path := range candidates {
		file, err = os.Open(path)
		if err == nil {
			foundPath = path
			break
		}
	}

	if file == nil {
		fmt.Println("âš ï¸ èª¤å¤‰æ›è¾æ›¸(CSV)ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚è¾æ›¸ãªã—ã§ç¶šè¡Œã—ã¾ã™ã€‚")
		// ãƒ‡ãƒãƒƒã‚°: ã©ã“ã‚’æ¢ã—ãŸã‹è¡¨ç¤ºã—ãŸæ–¹ãŒè¦ªåˆ‡ãªå ´åˆã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤–ã—ã¦ãã ã•ã„
		// fmt.Printf("(æ¢ç´¢ãƒ‘ã‚¹: %v)\n", candidates)
		return
	}
	defer file.Close()

	reader := csv.NewReader(file)
	_, _ = reader.Read() // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚¹ã‚­ãƒƒãƒ—
	records, _ := reader.ReadAll()

	for _, record := range records {
		if len(record) < 2 {
			continue
		}
		nameSubstitutions[record[0]] = Substitution{
			TargetName: record[1],
			Details:    strings.TrimSpace(getAt(record, 2)),
		}
	}
	fmt.Printf("ğŸ“š èª¤å¤‰æ›è¾æ›¸ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ(%s): %dä»¶\n", foundPath, len(nameSubstitutions))
}

func getAt(s []string, i int) string {
	if i < len(s) {
		return s[i]
	}
	return ""
}

// ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦å¼·åˆ¶å¤‰æ›ã‚’é©ç”¨ã™ã‚‹é–¢æ•°
func applySubstitutions(r *GeneratedRecipe) {
	for i := range r.Ingredients {
		ing := &r.Ingredients[i]
		if fix, ok := nameSubstitutions[ing.Name]; ok {
			// fmt.Printf("    ğŸ”„ å¤‰æ›: %s -> %s\n", ing.Name, fix.TargetName)
			ing.Name = fix.TargetName
			if ing.Details != "" && fix.Details != "" {
				ing.Details = fix.Details + " " + ing.Details
			} else if fix.Details != "" {
				ing.Details = fix.Details
			}
		}
	}
}

func saveRecipe(db *sql.DB, r *GeneratedRecipe, sourceURL string) {
	if r.Name == "" {
		return
	}
	var exists int
	db.QueryRow("SELECT count(*) FROM recipes WHERE name = ?", r.Name).Scan(&exists)
	if exists > 0 {
		fmt.Printf("    âš ï¸ ç™»éŒ²æ¸ˆã¿ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—\n")
		return
	}

	var processText string
	if r.Process != nil {
		switch v := r.Process.(type) {
		case string:
			processText = v
		case []interface{}:
			var lines []string
			for _, line := range v {
				if str, ok := line.(string); ok {
					lines = append(lines, str)
				}
			}
			processText = strings.Join(lines, "\n")
		default:
			processText = fmt.Sprintf("%v", v)
		}
	}
	if r.RawProcess == "" {
		r.RawProcess = processText
	}
	if r.RawIngredients == "" {
		b, _ := json.Marshal(r.Ingredients)
		r.RawIngredients = string(b)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Println("Txé–‹å§‹ã‚¨ãƒ©ãƒ¼:", err)
		return
	}

	res, err := tx.Exec("INSERT INTO recipes(name, yield, process, original_ingredients, original_process, url) VALUES(?, ?, ?, ?, ?, ?)",
		r.Name, r.Yield, processText, r.RawIngredients, r.RawProcess, sourceURL)
	if err != nil {
		tx.Rollback()
		log.Println("ä¿å­˜ã‚¨ãƒ©ãƒ¼:", err)
		return
	}
	recipeID, _ := res.LastInsertId()

	for _, ing := range r.Ingredients {
		if ing.Name == "" {
			continue
		}
		if len([]rune(ing.Name)) > 20 || strings.Contains(ing.Name, "å‘³å¤‰") {
			continue
		}

		// DBæ¤œç´¢
		var catalogID int
		db.QueryRow("SELECT id FROM item_catalog WHERE name = ?", ing.Name).Scan(&catalogID)

		detailsToSave := ing.Details

		if catalogID == 0 {
			// AIåå¯„ã›
			fmt.Printf("    â“ æœªçŸ¥: %s -> åå¯„ã›...", ing.Name)
			norm, err := askGeminiNormalize(ing.Name, apiKey)

			if err == nil && norm.StandardName != "" {
				// 1. æ¨™æº–åã§æ¤œç´¢
				db.QueryRow("SELECT id FROM item_catalog WHERE name = ?", norm.StandardName).Scan(&catalogID)

				// 2. ã‚«ãƒŠã§æ¤œç´¢ (AIãŒã€ŒãƒŠã‚¹(ã‚«ãƒŠ:ãªã™)ã€ã¨è¿”ã—ãŸå ´åˆã€DBã®ã€Œãªã™ã€ã«ãƒ’ãƒƒãƒˆã•ã›ã‚‹)
				if catalogID == 0 && norm.Kana != "" {
					db.QueryRow("SELECT id FROM item_catalog WHERE name = ?", norm.Kana).Scan(&catalogID)
					if catalogID != 0 {
						norm.StandardName = norm.Kana // ãƒ’ãƒƒãƒˆã—ãŸã‚‰åå‰ã‚’DBå´ã«åˆã‚ã›ã‚‹
					}
				}

				if catalogID != 0 {
					fmt.Printf(" ğŸ’¡ çµ±åˆ: %s (è©³ç´°:%s)\n", norm.StandardName, norm.Details)
					if norm.Details != "" {
						if detailsToSave != "" {
							detailsToSave += " " + norm.Details
						} else {
							detailsToSave = norm.Details
						}
					}
				} else {
					fmt.Printf(" ğŸ†• æ–°è¦: %s (%s)\n", norm.StandardName, norm.Kana)

					// æ–°è¦ç™»éŒ²
					err := tx.QueryRow("SELECT id FROM item_catalog WHERE name = ?", norm.StandardName).Scan(&catalogID)
					if err == sql.ErrNoRows {
						res, err := tx.Exec("INSERT INTO item_catalog(name, kana, classification, category, default_unit) VALUES(?, ?, ?, ?, ?)",
							norm.StandardName, norm.Kana, "é£Ÿæ", "æœªåˆ†é¡", "")
						if err == nil {
							nid, _ := res.LastInsertId()
							catalogID = int(nid)
						} else {
							tx.QueryRow("SELECT id FROM item_catalog WHERE name = ?", norm.StandardName).Scan(&catalogID)
						}
					}

					if norm.Details != "" {
						if detailsToSave != "" {
							detailsToSave += " " + norm.Details
						} else {
							detailsToSave = norm.Details
						}
					}
				}
			} else {
				fmt.Printf(" -> ãã®ã¾ã¾ç™»éŒ²\n")
				err := tx.QueryRow("SELECT id FROM item_catalog WHERE name = ?", ing.Name).Scan(&catalogID)
				if err == sql.ErrNoRows {
					res, err := tx.Exec("INSERT INTO item_catalog(name, kana, classification, category, default_unit) VALUES(?, ?, ?, ?, ?)",
						ing.Name, "", "é£Ÿæ", "æœªåˆ†é¡", "")
					if err == nil {
						nid, _ := res.LastInsertId()
						catalogID = int(nid)
					} else {
						tx.QueryRow("SELECT id FROM item_catalog WHERE name = ?", ing.Name).Scan(&catalogID)
					}
				}
			}
		}

		if catalogID != 0 {
			_, err := tx.Exec("INSERT INTO recipe_ingredients(recipe_id, catalog_id, unit, amount, group_name, details) VALUES(?, ?, ?, ?, ?, ?)",
				recipeID, catalogID, "", ing.Amount, ing.Group, detailsToSave)
			if err != nil {
				log.Printf("    âŒ ææ–™ä¿å­˜ã‚¨ãƒ©ãƒ¼(%s): %v", ing.Name, err)
			}
		}
	}

	if err := tx.Commit(); err != nil {
		log.Println("ã‚³ãƒŸãƒƒãƒˆã‚¨ãƒ©ãƒ¼:", err)
		return
	}
	fmt.Printf("    âœ… ä¿å­˜å®Œäº†\n")
}

func askGeminiNormalize(name, apiKey string) (*NormalizeResult, error) {
	// AIæŒ‡ç¤º: é‡èœã¯ã²ã‚‰ãŒãªå„ªå…ˆ
	prompt := fmt.Sprintf(`
é£Ÿæåã€Œ%sã€ã‚’æ­£è¦åŒ–ã—ã€JSONã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚

ã€é‡è¦: è¡¨è¨˜ãƒ«ãƒ¼ãƒ«ã€‘
1. ä¸€èˆ¬çš„ãªé‡èœï¼ˆãªã™ã€ã ã„ã“ã‚“ã€ã«ã‚“ã˜ã‚“ã€ãƒ”ãƒ¼ãƒãƒ³ç­‰ï¼‰ã¯ã€ç”Ÿç‰©å­¦çš„ãªã‚«ã‚¿ã‚«ãƒŠè¡¨è¨˜ã§ã¯ãªãã€**æ–™ç†ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨ã—ã¦ä¸€èˆ¬çš„ãªã€Œã²ã‚‰ãŒãªã€ã¾ãŸã¯ã€Œä¸€èˆ¬çš„ãªæ¼¢å­—ã€** ã«çµ±ä¸€ã—ã¦ãã ã•ã„ã€‚
   ä¾‹: ãƒŠã‚¹ -> ãªã™, èŒ„å­ -> ãªã™, ãƒ‹ãƒ© -> ãƒ‹ãƒ©(ã‚«ã‚¿ã‚«ãƒŠãŒä¸€èˆ¬çš„), ãƒ”ãƒ¼ãƒãƒ³ -> ãƒ”ãƒ¼ãƒãƒ³
2. ã€Œstandard_nameã€ã«ã¯ãã®çµ±ä¸€ã—ãŸåç§°ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚
3. ã€Œkanaã€ã«ã¯å…¨è§’ã²ã‚‰ãŒãªã®èª­ã¿ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚
4. ã€Œdetailsã€ã«ã¯å½¢çŠ¶ã‚„çŠ¶æ…‹ï¼ˆç²‰æœ«ã€ã¿ã˜ã‚“åˆ‡ã‚Šç­‰ï¼‰ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚

JSONå½¢å¼:
{"standard_name": "ãªã™", "kana": "ãªã™", "details": ""}
`, name)

	resStr, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, err
	}
	var res NormalizeResult
	if err := json.Unmarshal([]byte(resStr), &res); err != nil {
		return nil, err
	}
	return &res, nil
}

func fixDatabaseSchema(db *sql.DB) {
	db.Exec(`CREATE TABLE IF NOT EXISTS item_catalog (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL UNIQUE,
		kana TEXT,
		classification TEXT NOT NULL,
		category TEXT,
		default_unit TEXT
	);`)

	db.Exec(`CREATE TABLE IF NOT EXISTS recipes (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL UNIQUE,
		yield TEXT,
		process TEXT,
		url TEXT,
		original_ingredients TEXT DEFAULT '',
		original_process TEXT DEFAULT '',
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);`)

	db.Exec(`CREATE TABLE IF NOT EXISTS recipe_ingredients (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		recipe_id INTEGER NOT NULL,
		catalog_id INTEGER NOT NULL,
		unit TEXT,
		amount TEXT,
		group_name TEXT,
		details TEXT DEFAULT '',
		FOREIGN KEY (recipe_id) REFERENCES recipes (id),
		FOREIGN KEY (catalog_id) REFERENCES item_catalog (id)
	);`)

	sqls := []string{
		"ALTER TABLE recipes ADD COLUMN original_ingredients TEXT DEFAULT ''",
		"ALTER TABLE recipes ADD COLUMN original_process TEXT DEFAULT ''",
		"ALTER TABLE recipe_ingredients ADD COLUMN details TEXT DEFAULT ''",
		"ALTER TABLE item_catalog ADD COLUMN kana TEXT",
	}
	for _, q := range sqls {
		db.Exec(q)
	}
}

func analyzeManualText(text string, apiKey string) ([]GeneratedRecipe, string, error) {
	prompt := `
ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã€æ–™ç†ãƒ¬ã‚·ãƒ”ã®æƒ…å ±ã‚’æŠ½å‡ºã—ã€JSONé…åˆ—ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
ã€æŠ½å‡ºãƒ«ãƒ¼ãƒ«ã€‘
- name: æ–™ç†å
- yield: ä½•äººåˆ†ã‹
- ingredients: ææ–™ãƒªã‚¹ãƒˆ
    - name: ææ–™å
      â€»é‡è¦: "ã‹ã"ç­‰ã®åŒéŸ³ç•°ç¾©èªã¯ã€ãƒ¬ã‚·ãƒ”ã®æ–‡è„ˆï¼ˆé‹ãªã‚‰"ç‰¡è £"ã€ãƒ‡ã‚¶ãƒ¼ãƒˆãªã‚‰"æŸ¿"ï¼‰ã‹ã‚‰åˆ¤æ–­ã—ã¦é©åˆ‡ãªæ¼¢å­—ã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚
    - amount: åˆ†é‡ (å˜ä½è¾¼ã¿ã§è¨˜è¿°ã€‚ä¾‹: "1/2æœ¬", "200g", "å°‘ã€…")
    - group: ã‚°ãƒ«ãƒ¼ãƒ—åï¼ˆ"A", "ã‚½ãƒ¼ã‚¹"ãªã©ã€‚ãªã‘ã‚Œã°ç©ºæ–‡å­—ï¼‰
    - details: è©³ç´°æƒ…å ±ãƒ»è£œè¶³ï¼ˆä¾‹: "ã¿ã˜ã‚“åˆ‡ã‚Š", "å†·å‡", "é£¾ã‚Šç”¨"ãªã©ã€‚ãªã‘ã‚Œã°ç©ºæ–‡å­—ï¼‰
- raw_ingredients: ææ–™ãƒªã‚¹ãƒˆã®åŸæ–‡
- process: ä½œã‚Šæ–¹ã®æ‰‹é †
- raw_process: ä½œã‚Šæ–¹ã®åŸæ–‡
ã€ãƒ‡ãƒ¼ã‚¿ã€‘
` + text

	resStr, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, "", err
	}

	var recipes []GeneratedRecipe
	if err := json.Unmarshal([]byte(resStr), &recipes); err != nil {
		var single GeneratedRecipe
		if err2 := json.Unmarshal([]byte(resStr), &single); err2 == nil {
			return []GeneratedRecipe{single}, resStr, nil
		}
		return nil, resStr, fmt.Errorf("JSONè§£æå¤±æ•—: %v", err)
	}
	return recipes, resStr, nil
}

func printComparison(r *GeneratedRecipe) {
	fmt.Printf("ğŸ³ %s\n", r.Name)
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 4, ' ', 0)
	fmt.Fprintln(w, "ã€ åŸæ–‡ ã€‘\t|\tã€ AIè§£æ (3åˆ—å½¢å¼) ã€‘")
	fmt.Fprintln(w, "----------\t|\t-----------------------")

	rawLines := strings.Split(strings.TrimSpace(r.RawIngredients), "\n")
	var aiLines []string
	for _, ing := range r.Ingredients {
		line := fmt.Sprintf("%s : %s", ing.Name, ing.Amount)
		if ing.Details != "" {
			line += fmt.Sprintf(" (%s)", ing.Details)
		}
		if ing.Group != "" {
			line += fmt.Sprintf(" <%s>", ing.Group)
		}
		aiLines = append(aiLines, line)
	}

	maxLen := len(rawLines)
	if len(aiLines) > maxLen {
		maxLen = len(aiLines)
	}

	for i := 0; i < maxLen; i++ {
		left, right := "", ""
		if i < len(rawLines) {
			left = strings.TrimSpace(rawLines[i])
			if len([]rune(left)) > 20 {
				left = string([]rune(left)[:18]) + ".."
			}
		}
		if i < len(aiLines) {
			right = aiLines[i]
		}
		if left != "" || right != "" {
			fmt.Fprintf(w, "%s\t|\t%s\n", left, right)
		}
	}
	w.Flush()
	fmt.Println("--------------------------------------------------")
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\master_cleaner\main.go -----
package main

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"kimichan/tools/common"
)

type MasterCleanResult struct {
	RealName       string `json:"real_name"`
	Kana           string `json:"kana"`
	Classification string `json:"classification"`
	Category       string `json:"category"`
	Details        string `json:"details"`
}

type MasterRecord struct {
	Classification string
	Category       string
}

func main() {
	wd, _ := os.Getwd()
	cfg, err := common.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}

	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸ§¹ ã‚¹ãƒ¼ãƒ‘ãƒ¼ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆ (ã‚«ãƒ†ã‚´ãƒªå³å®ˆç‰ˆ)ã€èµ·å‹•ã—ã¾ã™...")

	// 1. ãƒã‚¹ã‚¿CSVèª­ã¿è¾¼ã¿ & ã‚«ãƒ†ã‚´ãƒªãƒªã‚¹ãƒˆä½œæˆ
	masterMap := make(map[string]MasterRecord)
	// é‡è¤‡ã—ãªã„ã‚«ãƒ†ã‚´ãƒªãƒªã‚¹ãƒˆã‚’ä½œã‚‹ãŸã‚ã®ã‚»ãƒƒãƒˆ
	categorySet := make(map[string]bool)
	categorySet["ãã®ä»–"] = true // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§å…¥ã‚Œã¦ãŠã

	csvPath := filepath.Join(wd, "seeds", "master_data.csv")
	if _, err := os.Stat(csvPath); os.IsNotExist(err) {
		csvPath = filepath.Join(wd, "..", "..", "seeds", "master_data.csv")
	}
	file, err := os.Open(csvPath)
	if err == nil {
		reader := csv.NewReader(file)
		_, _ = reader.Read()
		records, _ := reader.ReadAll()
		for _, r := range records {
			masterMap[r[0]] = MasterRecord{Classification: r[1], Category: r[2]}
			if r[2] != "" {
				categorySet[r[2]] = true
			}
		}
		file.Close()
		fmt.Printf("ğŸ“š ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ %d ä»¶ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚\n", len(masterMap))
	}

	// ã‚«ãƒ†ã‚´ãƒªãƒªã‚¹ãƒˆã‚’æ–‡å­—åˆ—åŒ–ï¼ˆAIã¸ã®æŒ‡ç¤ºç”¨ï¼‰
	var validCategories []string
	for cat := range categorySet {
		validCategories = append(validCategories, cat)
	}
	validCategoriesStr := strings.Join(validCategories, ", ")
	fmt.Printf("ğŸ“‹ æœ‰åŠ¹ã‚«ãƒ†ã‚´ãƒª: [%s]\n", validCategoriesStr)

	// 2. DBãƒã‚§ãƒƒã‚¯
	rows, err := db.Query("SELECT id, name, kana, classification, category FROM item_catalog")
	if err != nil {
		log.Fatal(err)
	}

	type Target struct {
		ID   int
		Name string
		Kana string
		Cls  string
		Cat  string
	}
	var targets []Target
	for rows.Next() {
		var t Target
		var k sql.NullString
		rows.Scan(&t.ID, &t.Name, &k, &t.Cls, &t.Cat)
		t.Kana = k.String
		targets = append(targets, t)
	}
	rows.Close()

	fmt.Printf("ğŸ“¦ å…¨ %d ä»¶ã®é£Ÿæã‚’æ¤œæŸ»ã—ã¾ã™ã€‚\n", len(targets))

	for i, t := range targets {
		// ãƒã‚¹ã‚¿ä¸€è‡´ãƒã‚§ãƒƒã‚¯
		master, inMaster := masterMap[t.Name]

		if inMaster && t.Cls == master.Classification && t.Cat == master.Category && t.Kana != "" {
			continue
		}

		fmt.Printf("[%d/%d] è£œå®Œä¸­: %s ... ", i+1, len(targets), t.Name)

		// â˜…ä¿®æ­£: AIã«æœ‰åŠ¹ã‚«ãƒ†ã‚´ãƒªãƒªã‚¹ãƒˆã‚’æ¸¡ã™
		res, err := askGeminiMaster(t.Name, validCategoriesStr, cfg.GeminiApiKey)
		if err != nil {
			fmt.Printf("âŒ AIã‚¨ãƒ©ãƒ¼: %v\n", err)
			continue
		}

		// ãƒã‚¹ã‚¿å„ªå…ˆï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ï¼‰
		if inMaster {
			res.Classification = master.Classification
			res.Category = master.Category
			res.RealName = t.Name
		}

		// å¤‰æ›´ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
		needsUpdate := false
		if res.RealName != t.Name {
			needsUpdate = true
		}
		if t.Cls == "" && res.Classification != "" {
			needsUpdate = true
		}
		// ã‚«ãƒ†ã‚´ãƒªãŒå¤‰ã‚ã‚‹ã‹ã€ã¾ãŸã¯ä»Šã®ã‚«ãƒ†ã‚´ãƒªãŒç„¡åŠ¹ãªã‚‚ã®ï¼ˆãƒªã‚¹ãƒˆã«ãªã„ï¼‰ã ã£ãŸå ´åˆã‚‚æ›´æ–°
		if (t.Cat == "" && res.Category != "") || (t.Cat != res.Category) {
			needsUpdate = true
		}
		if t.Kana == "" && res.Kana != "" {
			needsUpdate = true
		}
		if res.Details != "" {
			needsUpdate = true
		} // è©³ç´°ãŒåˆ†é›¢ã•ã‚ŒãŸã‚‰æ›´æ–°å¿…é ˆ

		if !needsUpdate {
			fmt.Println("ğŸ†— å¤‰æ›´ãªã—")
			continue
		}

		fmt.Printf("\n    ğŸ‘‰ ä¿®æ­£: [%s(%s)] åˆ†é¡:%s / ã‚«ãƒ†ã‚´ãƒª:%s\n",
			res.RealName, res.Kana, res.Classification, res.Category)
		if res.Details != "" {
			fmt.Printf("       è©³ç´°åˆ†é›¢: %s\n", res.Details)
		}

		if err := executeMasterClean(db, t.ID, res); err != nil {
			fmt.Printf("    âŒ DBæ›´æ–°ã‚¨ãƒ©ãƒ¼: %v\n", err)
		} else {
			fmt.Println("    âœ… å®Œäº†ï¼")
		}

		time.Sleep(1500 * time.Millisecond)
	}
	fmt.Println("\nâœ¨ å…¨ã¦ã®ãŠæƒé™¤ãŒå®Œäº†ã—ã¾ã—ãŸï¼")
}

// â˜…ä¿®æ­£: validCategoriesã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«å¤‰æ›´
func askGeminiMaster(name, validCategories, apiKey string) (*MasterCleanResult, error) {
	prompt := fmt.Sprintf(`
é£Ÿæåã€Œ%sã€ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åŒ–ã—ã¦JSONã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚

ã€ãƒ«ãƒ¼ãƒ«ã€‘
1. real_name: ä¸€èˆ¬åç§°ï¼ˆã€Œç‰ã­ã(ã¿ã˜ã‚“åˆ‡ã‚Š)ã€â†’ã€Œç‰ã­ãã€ï¼‰ã€‚
2. kana: å…¨è§’ã²ã‚‰ãŒãªã®èª­ã¿ï¼ˆä¾‹: ãŸã¾ã­ãï¼‰ã€‚å¿…é ˆã€‚
3. classification: ã€Œé£Ÿæã€ã‹ã€Œèª¿å‘³æ–™ã€ã€‚
4. category: ä»¥ä¸‹ã®ãƒªã‚¹ãƒˆã‹ã‚‰æœ€ã‚‚é©åˆ‡ãªã‚‚ã®ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚ã“ã‚Œä»¥å¤–ã®è¨€è‘‰ã¯ç¦æ­¢ã§ã™ã€‚
   [ %s ]
5. details: è£œè¶³æƒ…å ±ï¼ˆã¿ã˜ã‚“åˆ‡ã‚Šã€ã‚½ãƒ¼ã‚¹ç”¨ã€Aãªã©ï¼‰ã€‚ãªã‘ã‚Œã°ç©ºæ–‡å­—ã€‚
`, name, validCategories)

	txt, err := common.CallGemini(prompt, apiKey)
	if err != nil {
		return nil, err
	}

	var res MasterCleanResult
	if err := json.Unmarshal([]byte(txt), &res); err != nil {
		return nil, err
	}
	return &res, nil
}

func executeMasterClean(db *sql.DB, oldID int, res *MasterCleanResult) error {
	tx, err := db.Begin()
	if err != nil {
		return err
	}

	var masterID int
	err = tx.QueryRow("SELECT id FROM item_catalog WHERE name = ?", res.RealName).Scan(&masterID)

	if err == sql.ErrNoRows {
		query := `UPDATE item_catalog SET name=?, kana=?, classification=?, category=? WHERE id=?`
		_, err = tx.Exec(query, res.RealName, res.Kana, res.Classification, res.Category, oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
		masterID = oldID
	} else {
		if res.Kana != "" {
			tx.Exec("UPDATE item_catalog SET kana = ? WHERE id = ? AND (kana IS NULL OR kana = '')", res.Kana, masterID)
		}
	}

	if res.Details != "" {
		query := `UPDATE recipe_ingredients SET catalog_id = ?, details = CASE WHEN details = '' THEN ? ELSE details || ' ' || ? END WHERE catalog_id = ?`
		_, err = tx.Exec(query, masterID, res.Details, res.Details, oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
	} else if masterID != oldID {
		_, err = tx.Exec("UPDATE recipe_ingredients SET catalog_id = ? WHERE catalog_id = ?", masterID, oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	if masterID != oldID {
		_, err = tx.Exec("DELETE FROM item_catalog WHERE id = ?", oldID)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	return tx.Commit()
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\tools\seed_importer\main.go -----
package main

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"kimichan/tools/common"
)

func main() {
	// DBæ¥ç¶š
	db, err := common.ConnectDB()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fmt.Println("ğŸŒ± ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿å–è¾¼ãƒ„ãƒ¼ãƒ«ã€èµ·å‹•ã—ã¾ã™...")

	// CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
	wd, _ := os.Getwd()
	csvPath := filepath.Join(wd, "seeds", "master_data.csv")
	// ãƒ«ãƒ¼ãƒˆä»¥å¤–ã‹ã‚‰å®Ÿè¡Œã•ã‚ŒãŸå ´åˆç”¨
	if _, err := os.Stat(csvPath); os.IsNotExist(err) {
		csvPath = filepath.Join(wd, "..", "..", "seeds", "master_data.csv")
	}

	file, err := os.Open(csvPath)
	if err != nil {
		log.Fatalf("âŒ CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s", csvPath)
	}
	defer file.Close()

	reader := csv.NewReader(file)
	// ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
	_, _ = reader.Read()

	records, err := reader.ReadAll()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("ğŸ“¦ %d ä»¶ã®ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã—ã¾ã™ã€‚\n", len(records))

	tx, err := db.Begin()
	if err != nil {
		log.Fatal(err)
	}

	updated := 0
	inserted := 0

	for _, record := range records {
		name := record[0]
		classification := record[1]
		category := record[2]

		// æ—¢å­˜ãƒã‚§ãƒƒã‚¯
		var id int
		err := tx.QueryRow("SELECT id FROM item_catalog WHERE name = ?", name).Scan(&id)

		if err == sql.ErrNoRows {
			// æ–°è¦ç™»éŒ²
			_, err = tx.Exec("INSERT INTO item_catalog(name, classification, category, default_unit) VALUES(?, ?, ?, '')",
				name, classification, category)
			if err != nil {
				log.Println("ç™»éŒ²ã‚¨ãƒ©ãƒ¼:", err)
				continue
			}
			inserted++
		} else {
			// æ—¢å­˜ã‚ã‚Š -> æ­£ã—ã„åˆ†é¡ãƒ»ã‚«ãƒ†ã‚´ãƒªã§ä¸Šæ›¸ãï¼ˆä¿®æ­£ï¼‰
			_, err = tx.Exec("UPDATE item_catalog SET classification = ?, category = ? WHERE id = ?",
				classification, category, id)
			if err != nil {
				log.Println("æ›´æ–°ã‚¨ãƒ©ãƒ¼:", err)
				continue
			}
			updated++
		}
	}

	tx.Commit()
	fmt.Printf("âœ¨ å®Œäº†ã—ã¾ã—ãŸï¼ (æ–°è¦: %d ä»¶ / æ›´æ–°: %d ä»¶)\n", inserted, updated)
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\database.go -----
package main

import (
	"database/sql"
	"fmt"

	_ "github.com/mattn/go-sqlite3"
)

var db *sql.DB

// initDBé–¢æ•°ã¯å‰Šé™¤ã—ã¾ã—ãŸï¼ˆmain.goã§ç›´æ¥å‡¦ç†ã—ã¦ã„ã‚‹ãŸã‚ä¸è¦ï¼‰

func initDatabase() error {
	const createCatalogSQL = `
	CREATE TABLE IF NOT EXISTS item_catalog (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL UNIQUE,
		kana TEXT,
		classification TEXT NOT NULL,
		category TEXT,
		default_unit TEXT
	);`
	if _, err := db.Exec(createCatalogSQL); err != nil {
		return fmt.Errorf("item_catalog error: %w", err)
	}
	// ã‚«ãƒ©ãƒ è¿½åŠ ï¼ˆãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
	// æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã®ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã™ã‚‹ç°¡æ˜“å®Ÿè£…ï¼ˆã¾ãŸã¯ã‚«ãƒ©ãƒ å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã‚‹ã®ãŒä¸å¯§ã ãŒã€å€‹äººé–‹ç™ºãªã‚‰ã“ã‚Œã§ç¶šè¡Œå¯ï¼‰
	// ã“ã“ã§ã¯ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã‚‚æ­¢ã¾ã‚‰ãªã„ã‚ˆã†ã«Execã®çµæœã‚’ãƒã‚§ãƒƒã‚¯ã—ã¤ã¤ã€ç¶šè¡Œã•ã›ã‚‹å½¢ãŒå®‰å…¨ã§ã™ãŒ
	// SQLiteã¯ ADD COLUMN IF NOT EXISTS ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚‚ã‚ã‚‹ãŸã‚ã€
	// å³å¯†ã«ã¯ãƒã‚§ãƒƒã‚¯ãŒå¿…è¦ã€‚ãŸã ã€Goã®ãƒ‰ãƒ©ã‚¤ãƒãªã‚‰ã‚¨ãƒ©ãƒ¼ã§ã‚‚è½ã¡ãªã„ã®ã§ã“ã®ã¾ã¾ã§ã‚‚ç¨¼åƒã¯ã—ã¾ã™ã€‚
	db.Exec("ALTER TABLE item_catalog ADD COLUMN kana TEXT;")

	const createIngredientsSQL = `
	CREATE TABLE IF NOT EXISTS refrigerator_ingredients (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		catalog_id INTEGER NOT NULL,
		amount REAL,
		unit TEXT,
		expiration_date TEXT,
		location TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (catalog_id) REFERENCES item_catalog (id)
	);`
	if _, err := db.Exec(createIngredientsSQL); err != nil {
		return fmt.Errorf("refrigerator_ingredients error: %w", err)
	}
	db.Exec("ALTER TABLE refrigerator_ingredients ADD COLUMN location TEXT;")

	const createSeasoningsSQL = `
	CREATE TABLE IF NOT EXISTS refrigerator_seasonings (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		catalog_id INTEGER NOT NULL,
		status TEXT NOT NULL,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (catalog_id) REFERENCES item_catalog (id)
	);`
	if _, err := db.Exec(createSeasoningsSQL); err != nil {
		return fmt.Errorf("refrigerator_seasonings error: %w", err)
	}

	const createRecipesSQL = `
	CREATE TABLE IF NOT EXISTS recipes (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL UNIQUE,
		yield TEXT,
		process TEXT,
		url TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);`
	if _, err := db.Exec(createRecipesSQL); err != nil {
		return fmt.Errorf("recipes error: %w", err)
	}
	// ä¸è¶³ã—ã¦ã„ãŸã‚«ãƒ©ãƒ ã‚’è¿½åŠ 
	db.Exec("ALTER TABLE recipes ADD COLUMN yield TEXT;")
	db.Exec("ALTER TABLE recipes ADD COLUMN original_ingredients TEXT DEFAULT '';")
	db.Exec("ALTER TABLE recipes ADD COLUMN original_process TEXT DEFAULT '';")

	const createRecipeIngredientsSQL = `
	CREATE TABLE IF NOT EXISTS recipe_ingredients (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		recipe_id INTEGER NOT NULL,
		catalog_id INTEGER NOT NULL,
		unit TEXT,
		amount TEXT,
		group_name TEXT,
		details TEXT,
		FOREIGN KEY (recipe_id) REFERENCES recipes (id),
		FOREIGN KEY (catalog_id) REFERENCES item_catalog (id)
	);`
	if _, err := db.Exec(createRecipeIngredientsSQL); err != nil {
		return fmt.Errorf("recipe_ingredients error: %w", err)
	}

	db.Exec("ALTER TABLE recipe_ingredients ADD COLUMN unit TEXT;")
	db.Exec("ALTER TABLE recipe_ingredients ADD COLUMN group_name TEXT;")
	db.Exec("ALTER TABLE recipe_ingredients ADD COLUMN details TEXT DEFAULT '';")

	const createFridgePhotosSQL = `
	CREATE TABLE IF NOT EXISTS fridge_photos (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		image_path TEXT NOT NULL,
		location TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);`
	if _, err := db.Exec(createFridgePhotosSQL); err != nil {
		return fmt.Errorf("fridge_photos error: %w", err)
	}
	db.Exec("ALTER TABLE fridge_photos ADD COLUMN location TEXT;")

	// â˜…å‰Šé™¤: èª¿å‘³æ–™ã®ã‚«ãƒ†ã‚´ãƒªã‚’å‹æ‰‹ã«æ¶ˆã™ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ
	// const updateSeasoningsSQL = ... (å‰Šé™¤)

	fmt.Println("Database initialized.")
	return nil
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\go.mod -----
module kimichan

go 1.24.3

require (
	github.com/PuerkitoBio/goquery v1.11.0
	github.com/mattn/go-sqlite3 v1.14.32
)

require (
	github.com/andybalholm/cascadia v1.3.3 // indirect
	golang.org/x/net v0.47.0 // indirect
)


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\go.sum -----
github.com/PuerkitoBio/goquery v1.11.0 h1:jZ7pwMQXIITcUXNH83LLk+txlaEy6NVOfTuP43xxfqw=
github.com/PuerkitoBio/goquery v1.11.0/go.mod h1:wQHgxUOU3JGuj3oD/QFfxUdlzW6xPHfqyHre6VMY4DQ=
github.com/andybalholm/cascadia v1.3.3 h1:AG2YHrzJIm4BZ19iwJ/DAua6Btl3IwJX+VI4kktS1LM=
github.com/andybalholm/cascadia v1.3.3/go.mod h1:xNd9bqTn98Ln4DwST8/nG+H0yuB8Hmgu1YHNnWw0GeA=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/mattn/go-sqlite3 v1.14.32 h1:JD12Ag3oLy1zQA+BNn74xRgaBbdhbNIDYvQUEuuErjs=
github.com/mattn/go-sqlite3 v1.14.32/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=
golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=
golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
golang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=
golang.org/x/net v0.47.0 h1:Mx+4dIFzqraBXUugkia1OOvlD6LemFo1ALMHjrXDOhY=
golang.org/x/net v0.47.0/go.mod h1:/jNxtkgq5yWUGYkaZGqo27cfGZ1c5Nen03aYrrKpVRU=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=
golang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=
golang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=
golang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=
golang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_catalog.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
)

func handleCatalog(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getCatalogItems(w, r)
	case "POST":
		addCatalogItems(w, r)
	case "PUT":
		updateCatalogItem(w, r)
	case "DELETE":
		deleteCatalogItem(w, r)
	default:
		sendJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func handleCatalogUsage(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		sendJSONError(w, "id required", http.StatusBadRequest)
		return
	}

	var recipeCount int
	err := db.QueryRow("SELECT COUNT(DISTINCT recipe_id) FROM recipe_ingredients WHERE catalog_id = ?", idStr).Scan(&recipeCount)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	rows, err := db.Query("SELECT DISTINCT r.name FROM recipes r JOIN recipe_ingredients ri ON r.id = ri.recipe_id WHERE ri.catalog_id = ? LIMIT 3", idStr)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var recipeNames []string
	for rows.Next() {
		var name string
		rows.Scan(&name)
		recipeNames = append(recipeNames, name)
	}

	response := map[string]interface{}{
		"recipe_count": recipeCount,
		"recipe_names": recipeNames,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func getCatalogItems(w http.ResponseWriter, _ *http.Request) {
	rows, err := db.Query("SELECT id, name, kana, classification, category, default_unit FROM item_catalog ORDER BY name ASC")
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	items := []CatalogItem{}
	for rows.Next() {
		var item CatalogItem
		var kana sql.NullString
		if err := rows.Scan(&item.ID, &item.Name, &kana, &item.Classification, &item.Category, &item.DefaultUnit); err != nil {
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		item.Kana = kana.String
		items = append(items, item)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(items)
}

func addCatalogItems(w http.ResponseWriter, r *http.Request) {
	var items []CatalogItem
	if err := json.NewDecoder(r.Body).Decode(&items); err != nil {
		sendJSONError(w, err.Error(), http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	query := `
	INSERT INTO item_catalog(name, kana, classification, category, default_unit) 
	VALUES(?, ?, ?, ?, ?)
	ON CONFLICT(name) DO UPDATE SET
	kana = excluded.kana,
	classification = excluded.classification,
	category = excluded.category,
	default_unit = excluded.default_unit
	`
	stmt, err := tx.Prepare(query)
	if err != nil {
		tx.Rollback()
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	for _, item := range items {
		if item.Name == "" {
			tx.Rollback()
			sendJSONError(w, "name required", http.StatusBadRequest)
			return
		}
		_, err := stmt.Exec(item.Name, item.Kana, item.Classification, item.Category, item.DefaultUnit)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func updateCatalogItem(w http.ResponseWriter, r *http.Request) {
	type UpdateReq struct {
		ID             int    `json:"id"`
		Name           string `json:"name"`
		Kana           string `json:"kana"`
		Classification string `json:"classification"`
		Category       string `json:"category"`
		DefaultUnit    string `json:"default_unit"`
		ForceMerge     bool   `json:"force_merge"`
	}
	var req UpdateReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendJSONError(w, err.Error(), http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	var targetID int
	err = tx.QueryRow("SELECT id FROM item_catalog WHERE name = ? AND id != ?", req.Name, req.ID).Scan(&targetID)

	if err == nil {
		if !req.ForceMerge {
			tx.Rollback()
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusConflict)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error_code": "merge_confirmation_required",
				"message":    fmt.Sprintf("ã€Œ%sã€ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚çµ±åˆã—ã¾ã™ã‹ï¼Ÿ", req.Name),
				"target_id":  targetID,
			})
			return
		}

		// çµ±åˆå‡¦ç†
		tx.Exec("UPDATE refrigerator_ingredients SET catalog_id = ? WHERE catalog_id = ?", targetID, req.ID)
		tx.Exec("UPDATE recipe_ingredients SET catalog_id = ? WHERE catalog_id = ?", targetID, req.ID)
		// èª¿å‘³æ–™ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ç„¡è¦–
		tx.Exec("DELETE FROM item_catalog WHERE id = ?", req.ID)

	} else {
		query := `UPDATE item_catalog SET name=?, kana=?, classification=?, category=?, default_unit=? WHERE id=?`
		if _, err := tx.Exec(query, req.Name, req.Kana, req.Classification, req.Category, req.DefaultUnit, req.ID); err != nil {
			tx.Rollback()
			sendJSONError(w, "æ›´æ–°å¤±æ•—: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func deleteCatalogItem(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		sendJSONError(w, "id required", http.StatusBadRequest)
		return
	}
	var id int
	fmt.Sscanf(idStr, "%d", &id)

	// ä½¿ç”¨ãƒã‚§ãƒƒã‚¯ (èª¿å‘³æ–™ãƒ†ãƒ¼ãƒ–ãƒ«ã¯è¦‹ãªã„)
	var count int
	db.QueryRow("SELECT count(*) FROM recipe_ingredients WHERE catalog_id = ?", id).Scan(&count)
	if count > 0 {
		sendJSONError(w, "ãƒ¬ã‚·ãƒ”ã§ä½¿ç”¨ä¸­ã®ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“", http.StatusConflict)
		return
	}
	db.QueryRow("SELECT count(*) FROM refrigerator_ingredients WHERE catalog_id = ?", id).Scan(&count)
	if count > 0 {
		sendJSONError(w, "åœ¨åº«ã«ã‚ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“", http.StatusConflict)
		return
	}

	_, err := db.Exec("DELETE FROM item_catalog WHERE id = ?", id)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_export.go -----
package main

import (
	"encoding/csv"
	"fmt"
	"net/http"
	"time"
)

func exportCatalogCSV(w http.ResponseWriter, r *http.Request) {
	rows, err := db.Query("SELECT name, classification, category, default_unit, kana FROM item_catalog ORDER BY classification, name")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	fileName := fmt.Sprintf("catalog_export_%s.csv", time.Now().Format("20060102150405"))
	w.Header().Set("Content-Type", "text/csv")
	w.Header().Set("Content-Disposition", "attachment; filename=\""+fileName+"\"")

	writer := csv.NewWriter(w)
	defer writer.Flush()

	for rows.Next() {
		var name, classification, category, defaultUnit, kana NullString
		if err := rows.Scan(&name, &classification, &category, &defaultUnit, &kana); err != nil {
			http.Error(w, "è¡Œãƒ‡ãƒ¼ã‚¿ã®èª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
			return
		}
		record := []string{name.String, classification.String, category.String, defaultUnit.String, kana.String}
		if err := writer.Write(record); err != nil {
			http.Error(w, "CSVè¡Œã®æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
	if err := rows.Err(); err != nil {
		http.Error(w, "è¡Œã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
		return
	}
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_fridge_photos.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
)

func handleFridgePhotos(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getFridgePhotos(w, r)
	case "POST":
		addFridgePhoto(w, r)
	case "DELETE":
		deleteFridgePhoto(w, r)
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func getFridgePhotos(w http.ResponseWriter, _ *http.Request) {
	// location ã‚‚å–å¾—ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
	rows, err := db.Query("SELECT id, image_path, location, created_at FROM fridge_photos ORDER BY id DESC")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	photos := []FridgePhoto{}
	for rows.Next() {
		var p FridgePhoto
		var loc sql.NullString
		// location ã‚’ã‚¹ã‚­ãƒ£ãƒ³
		if err := rows.Scan(&p.ID, &p.ImagePath, &loc, &p.CreatedAt); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		p.Location = loc.String
		photos = append(photos, p)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(photos)
}

func addFridgePhoto(w http.ResponseWriter, r *http.Request) {
	var p FridgePhoto
	if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if p.ImagePath == "" {
		http.Error(w, "image_path required", http.StatusBadRequest)
		return
	}
	// å ´æ‰€ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€Œãã®ä»–ã€ã¨ã™ã‚‹
	if p.Location == "" {
		p.Location = "ãã®ä»–"
	}

	// location ã‚’DBã«ä¿å­˜
	res, err := db.Exec("INSERT INTO fridge_photos(image_path, location) VALUES(?, ?)", p.ImagePath, p.Location)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	id, _ := res.LastInsertId()
	p.ID = int(id)

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(p)
}

func deleteFridgePhoto(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}
	var id int
	fmt.Sscanf(idStr, "%d", &id)

	_, err := db.Exec("DELETE FROM fridge_photos WHERE id = ?", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_import.go -----
package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"io"
	"net/http"
	"strings"
)

type ImportResult struct {
	Added   int      `json:"added"`
	Skipped int      `json:"skipped"`
	Errors  []string `json:"errors,omitempty"`
}

func handleCatalogImport(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ", http.StatusBadRequest)
		return
	}
	r.Body.Close()

	if len(bodyBytes) >= 3 && bodyBytes[0] == 0xEF && bodyBytes[1] == 0xBB && bodyBytes[2] == 0xBF {
		bodyBytes = bodyBytes[3:]
	}

	reader := csv.NewReader(bytes.NewReader(bodyBytes))
	reader.FieldsPerRecord = -1

	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: "+err.Error(), http.StatusInternalServerError)
		return
	}

	checkStmt, err := tx.Prepare("SELECT id FROM item_catalog WHERE name = ?")
	if err != nil {
		tx.Rollback()
		http.Error(w, "DBæº–å‚™ã‚¨ãƒ©ãƒ¼: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer checkStmt.Close()

	insertStmt, err := tx.Prepare("INSERT INTO item_catalog (name, classification, category, default_unit, kana) VALUES (?, ?, ?, ?, ?)")
	if err != nil {
		tx.Rollback()
		http.Error(w, "DBæº–å‚™ã‚¨ãƒ©ãƒ¼: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer insertStmt.Close()

	result := ImportResult{}

	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			continue
		}
		if len(record) < 1 {
			continue
		}

		name := strings.TrimSpace(record[0])
		if name == "" {
			continue
		}

		classification := "é£Ÿæ"
		if len(record) > 1 {
			classification = strings.TrimSpace(record[1])
		}

		category := ""
		if len(record) > 2 {
			category = strings.TrimSpace(record[2])
		}

		unit := ""
		if len(record) > 3 {
			unit = strings.TrimSpace(record[3])
		}

		kana := ""
		if len(record) > 4 {
			kana = strings.TrimSpace(record[4])
		}

		if classification == "" {
			classification = "é£Ÿæ"
		}
		if classification == "èª¿å‘³æ–™" {
			category = ""
		}

		var existingID int
		err = checkStmt.QueryRow(name).Scan(&existingID)
		if err == nil {
			result.Skipped++
			continue
		}

		_, err = insertStmt.Exec(name, classification, category, unit, kana)
		if err != nil {
			result.Errors = append(result.Errors, name+": "+err.Error())
			continue
		}
		result.Added++
	}

	if err := tx.Commit(); err != nil {
		http.Error(w, "ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_ingredients.go -----
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
)

func handleIngredients(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getIngredients(w, r)
	case "POST":
		addIngredient(w, r)
	case "PUT":
		updateIngredient(w, r)
	case "DELETE":
		deleteIngredient(w, r)
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func getIngredients(w http.ResponseWriter, r *http.Request) {
	isAll := r.URL.Query().Get("all") == "true"

	// â˜…ä¿®æ­£: c.kana ã‚‚å–å¾—ã™ã‚‹
	query := `
		SELECT 
			i.id, i.catalog_id, i.amount, i.unit, i.expiration_date, i.location, i.created_at, i.updated_at,
			c.name, c.kana,
			(SELECT COUNT(*) FROM recipe_ingredients ri WHERE ri.catalog_id = c.id) as recipe_count
		FROM refrigerator_ingredients i
		JOIN item_catalog c ON i.catalog_id = c.id
		ORDER BY i.location ASC, c.name ASC
	`

	if isCloud := os.Getenv("K_SERVICE") != ""; isCloud && !isAll {
		query += " LIMIT 100"
	}

	rows, err := db.Query(query)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	ingredients := []Ingredient{}
	for rows.Next() {
		var item Ingredient
		var kana sql.NullString // ã‚«ãƒŠã¯ç©ºã®å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§NullStringã§å—ã‘ã‚‹
		if err := rows.Scan(
			&item.ID, &item.CatalogID, &item.Amount, &item.Unit, &item.ExpirationDate, &item.Location, &item.CreatedAt, &item.UpdatedAt,
			&item.Name, &kana, &item.RecipeCount,
		); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		item.Kana = kana.String // æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦ã‚»ãƒƒãƒˆ
		ingredients = append(ingredients, item)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(ingredients)
}
func addIngredient(w http.ResponseWriter, r *http.Request) {
	var item Ingredient
	if err := json.NewDecoder(r.Body).Decode(&item); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if item.CatalogID == 0 {
		http.Error(w, "catalog_id required", http.StatusBadRequest)
		return
	}
	if item.Location == "" {
		item.Location = "ãã®ä»–"
	}

	stmt, err := db.Prepare("INSERT INTO refrigerator_ingredients(catalog_id, amount, unit, expiration_date, location) VALUES(?, ?, ?, ?, ?)")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	res, err := stmt.Exec(item.CatalogID, item.Amount, item.Unit, item.ExpirationDate, item.Location)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	id, _ := res.LastInsertId()
	item.ID = int(id)

	w.WriteHeader(http.StatusCreated)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(item)
}

func updateIngredient(w http.ResponseWriter, r *http.Request) {
	var item Ingredient
	if err := json.NewDecoder(r.Body).Decode(&item); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if item.ID == 0 {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}

	_, err := db.Exec("UPDATE refrigerator_ingredients SET amount=?, expiration_date=?, location=?, updated_at=datetime('now','localtime') WHERE id=?", item.Amount, item.ExpirationDate, item.Location, item.ID)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "updated"})
}

func deleteIngredient(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}

	var id int
	fmt.Sscanf(idStr, "%d", &id)

	_, err := db.Exec("DELETE FROM refrigerator_ingredients WHERE id=?", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_locations.go -----
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// â˜…å‰Šé™¤: type Location struct ... ã®å®šç¾©ã‚’ã“ã“ã‹ã‚‰æ¶ˆå»ã—ã¾ã™
// ï¼ˆmodels.go ã«å®šç¾©æ¸ˆã¿ã®ãŸã‚ï¼‰

func handleLocations(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getLocations(w, r)
	case "POST":
		addLocation(w, r)
	case "PUT":
		reorderLocations(w, r)
	case "DELETE":
		deleteLocation(w, r)
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func getLocations(w http.ResponseWriter, _ *http.Request) {
	rows, err := db.Query("SELECT id, name, priority FROM locations ORDER BY priority ASC")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	locations := []Location{}
	for rows.Next() {
		var l Location
		if err := rows.Scan(&l.ID, &l.Name, &l.Priority); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		locations = append(locations, l)
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(locations)
}

func addLocation(w http.ResponseWriter, r *http.Request) {
	var l Location
	if err := json.NewDecoder(r.Body).Decode(&l); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if l.Name == "" {
		http.Error(w, "name required", http.StatusBadRequest)
		return
	}

	var maxPriority int
	db.QueryRow("SELECT COALESCE(MAX(priority), 0) FROM locations").Scan(&maxPriority)

	res, err := db.Exec("INSERT INTO locations(name, priority) VALUES(?, ?)", l.Name, maxPriority+1)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	id, _ := res.LastInsertId()
	l.ID = int(id)
	l.Priority = maxPriority + 1

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(l)
}

func deleteLocation(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		http.Error(w, "id required", http.StatusBadRequest)
		return
	}
	var id int
	fmt.Sscanf(idStr, "%d", &id)

	_, err := db.Exec("DELETE FROM locations WHERE id = ?", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}

func reorderLocations(w http.ResponseWriter, r *http.Request) {
	var items []Location
	if err := json.NewDecoder(r.Body).Decode(&items); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	for i, item := range items {
		_, err := tx.Exec("UPDATE locations SET priority = ? WHERE id = ?", i+1, item.ID)
		if err != nil {
			tx.Rollback()
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	tx.Commit()
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_photos.go -----
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

func handleUpload(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	r.ParseMultipartForm(10 << 20)

	file, handler, err := r.FormFile("photo")
	if err != nil {
		http.Error(w, "ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", http.StatusBadRequest)
		return
	}
	defer file.Close()

	ext := filepath.Ext(handler.Filename)
	if ext == "" {
		ext = ".jpg"
	}
	filename := fmt.Sprintf("img_%d%s", time.Now().UnixNano(), ext)

	savePath := filepath.Join(DataDir, "images", filename)

	dst, err := os.Create(savePath)
	if err != nil {
		http.Error(w, "ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer dst.Close()

	if _, err := io.Copy(dst, file); err != nil {
		http.Error(w, "æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"status":   "success",
		"filename": filename,
	})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\handlers_recipes.go -----
package main

import (
	"bufio"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
)

type RecipeRequest struct {
	Name                string `json:"name"`
	Yield               string `json:"yield"`
	Process             string `json:"process"`
	OriginalProcess     string `json:"original_process"`
	URL                 string `json:"url"`
	CsvData             string `json:"csv_data"`
	OriginalIngredients string `json:"original_ingredients"`
}

type RecipeResponse struct {
	Recipe
	HasIngredients bool `json:"has_ingredients"`
	HasSeasonings  bool `json:"has_seasonings"`
}

func handleRecipes(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		getRecipes(w, r)
	case "POST":
		addRecipe(w, r)
	case "PUT":
		updateRecipe(w, r)
	default:
		sendJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func sendJSONError(w http.ResponseWriter, message string, code int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(map[string]string{"error": message})
}

func sendMissingIngredientsError(w http.ResponseWriter, items []string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error_code": "missing_ingredients",
		"items":      items,
	})
}

func getRecipes(w http.ResponseWriter, r *http.Request) {
	filterIngredientID := r.URL.Query().Get("ingredient_id")
	isAll := r.URL.Query().Get("all") == "true"

	var query string
	var args []interface{}

	if filterIngredientID != "" {
		query = `SELECT r.id, r.name, r.yield, r.process, r.original_process, r.url, r.created_at, r.original_ingredients FROM recipes r JOIN recipe_ingredients ri ON r.id = ri.recipe_id WHERE ri.catalog_id = ? ORDER BY r.created_at DESC`
		args = append(args, filterIngredientID)
	} else {
		query = `SELECT id, name, yield, process, original_process, url, created_at, original_ingredients FROM recipes ORDER BY created_at DESC`
	}

	isCloud := os.Getenv("K_SERVICE") != ""
	if isCloud && !isAll {
		query += " LIMIT 50"
	}

	rows, err := db.Query(query, args...)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	recipes := []RecipeResponse{}
	for rows.Next() {
		var r RecipeResponse
		var yield, origProc, origIng sql.NullString
		if err := rows.Scan(&r.ID, &r.Name, &yield, &r.Process, &origProc, &r.URL, &r.CreatedAt, &origIng); err != nil {
			continue
		}
		r.Yield = yield.String
		r.OriginalProcess = origProc.String
		r.OriginalIngredients = origIng.String
		recipes = append(recipes, r)
	}

	if len(recipes) == 0 {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(recipes)
		return
	}

	recipeIDs := make([]interface{}, len(recipes))
	placeholders := make([]string, len(recipes))
	for i, r := range recipes {
		recipeIDs[i] = r.ID
		placeholders[i] = "?"
	}

	queryIng := fmt.Sprintf(`
		SELECT ri.recipe_id, ri.catalog_id, c.classification 
		FROM recipe_ingredients ri 
		JOIN item_catalog c ON ri.catalog_id = c.id 
		WHERE ri.recipe_id IN (%s)
	`, strings.Join(placeholders, ","))

	rowsIng, err := db.Query(queryIng, recipeIDs...)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rowsIng.Close()

	type IngInfo struct {
		CatalogID      int
		Classification string
	}
	recipeIngMap := make(map[int][]IngInfo)

	for rowsIng.Next() {
		var rID, cID int
		var cls string
		if err := rowsIng.Scan(&rID, &cID, &cls); err == nil {
			recipeIngMap[rID] = append(recipeIngMap[rID], IngInfo{CatalogID: cID, Classification: cls})
		}
	}

	invMap := make(map[int]bool)
	rowsInv, _ := db.Query("SELECT catalog_id FROM refrigerator_ingredients")
	if rowsInv != nil {
		for rowsInv.Next() {
			var cid int
			rowsInv.Scan(&cid)
			invMap[cid] = true
		}
		rowsInv.Close()
	}

	for i := range recipes {
		hasIng := true
		hasSeas := true
		ingredients := recipeIngMap[recipes[i].ID]

		for _, ing := range ingredients {
			inStock := invMap[ing.CatalogID]
			if ing.Classification == "èª¿å‘³æ–™" {
				if !inStock {
					hasSeas = false
				}
			} else {
				if !inStock {
					hasIng = false
				}
			}
		}
		recipes[i].HasIngredients = hasIng
		recipes[i].HasSeasonings = hasSeas
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(recipes)
}

func addRecipe(w http.ResponseWriter, r *http.Request) {
	saveRecipeCommon(w, r, 0)
}

func updateRecipe(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Query().Get("id")
	if idStr == "" {
		sendJSONError(w, "ID required", http.StatusBadRequest)
		return
	}
	var id int
	fmt.Sscanf(idStr, "%d", &id)
	saveRecipeCommon(w, r, id)
}

func saveRecipeCommon(w http.ResponseWriter, r *http.Request, id int) {
	var req RecipeRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendJSONError(w, err.Error(), http.StatusBadRequest)
		return
	}
	if req.Name == "" {
		sendJSONError(w, "ãƒ¬ã‚·ãƒ”åã¯å¿…é ˆã§ã™", http.StatusBadRequest)
		return
	}

	// 3åˆ—ä»•æ§˜: Amountã«å˜ä½è¾¼ã¿ã€Detailsã‚’è¿½åŠ 
	type parsedIng struct {
		CatalogID int
		Unit      string
		Amount    string
		GroupName string
		Details   string
	}
	var ingredients []parsedIng
	var unknownItems []string

	tx, err := db.Begin()
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// â˜…ä¿®æ­£: ã€Œ/ã€ã‚’æ”¹è¡Œã«å¤‰æ›ã™ã‚‹å‡¦ç†ã‚’å‰Šé™¤ã—ã¾ã—ãŸ
	// ãã®ã¾ã¾ req.CsvData ã‚’èª­ã¿è¾¼ã¿ã¾ã™
	scanner := bufio.NewScanner(strings.NewReader(req.CsvData))
	var currentGroup string

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		if strings.HasPrefix(line, "=") || strings.HasPrefix(line, "ï¼") {
			currentGroup = strings.Trim(line, "=ï¼ \tã€€")
			continue
		}

		var name, amount, details string

		if strings.Contains(line, ",") {
			parts := strings.Split(line, ",")
			name = strings.TrimSpace(parts[0])
			// 2åˆ—ç›®: åˆ†é‡(å˜ä½è¾¼ã¿)
			if len(parts) > 1 {
				amount = strings.TrimSpace(parts[1])
			}
			// 3åˆ—ç›®: è©³ç´°
			if len(parts) > 2 {
				details = strings.TrimSpace(parts[2])
			}
		} else if strings.Contains(line, "â€¦") {
			parts := strings.SplitN(line, "â€¦", 2)
			name = strings.TrimSpace(parts[0])
			if len(parts) > 1 {
				amount = strings.TrimSpace(parts[1])
			}
		} else if strings.Contains(line, "...") {
			parts := strings.SplitN(line, "...", 2)
			name = strings.TrimSpace(parts[0])
			if len(parts) > 1 {
				amount = strings.TrimSpace(parts[1])
			}
		} else {
			name = line
		}

		if name == "" {
			continue
		}

		var catalogID int
		err = tx.QueryRow("SELECT id FROM item_catalog WHERE name = ? OR kana = ?", name, name).Scan(&catalogID)
		if err != nil {
			unknownItems = append(unknownItems, name)
			continue
		}

		ingredients = append(ingredients, parsedIng{
			CatalogID: catalogID,
			Unit:      "", // å˜ä½ã‚«ãƒ©ãƒ ã¯ç©ºã«ã™ã‚‹
			Amount:    amount,
			GroupName: currentGroup,
			Details:   details,
		})
	}

	if len(unknownItems) > 0 {
		tx.Rollback()
		sendMissingIngredientsError(w, unknownItems)
		return
	}

	if id == 0 {
		res, err := tx.Exec("INSERT INTO recipes(name, yield, process, url, original_ingredients, original_process) VALUES(?, ?, ?, ?, ?, ?)",
			req.Name, req.Yield, req.Process, req.URL, req.OriginalIngredients, req.OriginalProcess)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		newID, _ := res.LastInsertId()
		id = int(newID)
	} else {
		_, err := tx.Exec("UPDATE recipes SET name=?, yield=?, process=?, url=?, original_ingredients=?, original_process=? WHERE id=?",
			req.Name, req.Yield, req.Process, req.URL, req.OriginalIngredients, req.OriginalProcess, id)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		_, err = tx.Exec("DELETE FROM recipe_ingredients WHERE recipe_id=?", id)
		if err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	ingStmt, err := tx.Prepare("INSERT INTO recipe_ingredients(recipe_id, catalog_id, unit, amount, group_name, details) VALUES(?, ?, ?, ?, ?, ?)")
	if err != nil {
		tx.Rollback()
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer ingStmt.Close()

	for _, ing := range ingredients {
		if _, err := ingStmt.Exec(id, ing.CatalogID, ing.Unit, ing.Amount, ing.GroupName, ing.Details); err != nil {
			tx.Rollback()
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func handleRecipeIngredients(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		sendJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	recipeID := r.URL.Query().Get("id")
	if recipeID == "" {
		sendJSONError(w, "id is required", http.StatusBadRequest)
		return
	}

	query := `
		SELECT 
			c.name, 
			ri.amount, 
			ri.unit,
			ri.group_name,
			ri.details,
			ri.catalog_id, 
			(SELECT COUNT(*) FROM refrigerator_ingredients WHERE catalog_id = c.id) as stock_count
		FROM recipe_ingredients ri
		JOIN item_catalog c ON ri.catalog_id = c.id
		WHERE ri.recipe_id = ?
		ORDER BY ri.id ASC
	`

	rows, err := db.Query(query, recipeID)
	if err != nil {
		sendJSONError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	type ResIngredient struct {
		Name      string `json:"name"`
		Amount    string `json:"amount"`
		Unit      string `json:"unit"`
		GroupName string `json:"group_name"`
		Details   string `json:"details"`
		CatalogID int    `json:"catalog_id"`
		InStock   bool   `json:"in_stock"`
	}

	var ingredients []ResIngredient
	for rows.Next() {
		var i ResIngredient
		var stockCount int
		var gn, dt sql.NullString
		if err := rows.Scan(&i.Name, &i.Amount, &i.Unit, &gn, &dt, &i.CatalogID, &stockCount); err != nil {
			sendJSONError(w, err.Error(), http.StatusInternalServerError)
			return
		}
		i.GroupName = gn.String
		i.Details = dt.String
		i.InStock = (stockCount > 0)
		ingredients = append(ingredients, i)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(ingredients)
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\main.go -----
package main

import (
	"database/sql"
	"embed"
	"fmt"
	"io/fs"
	"log"
	"net/http"
	"os"
	"path/filepath"

	_ "github.com/mattn/go-sqlite3"
)

//go:embed static/*
var staticFiles embed.FS

var DataDir string

func main() {
	currentDir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	// ãƒ‡ãƒ¼ã‚¿ä¿å­˜å ´æ‰€
	DataDir = filepath.Join(currentDir, "data")
	if err := os.MkdirAll(DataDir, 0755); err != nil {
		log.Fatal(err)
	}

	imagesPath := filepath.Join(DataDir, "images")
	if err := os.MkdirAll(imagesPath, 0755); err != nil {
		log.Fatal(err)
	}

	dbPath := filepath.Join(DataDir, "kimichan.db")
	db, err = sql.Open("sqlite3", dbPath)
	if err != nil {
		log.Fatalf("DB connection failed: %v", err)
	}
	defer db.Close()

	if err := initDatabase(); err != nil {
		log.Fatalf("DB init failed: %v", err)
	}

	mux := http.NewServeMux()

	// ãƒãƒ³ãƒ‰ãƒ©ç™»éŒ²ï¼ˆèª¿å‘³æ–™ã¯å‰Šé™¤æ¸ˆã¿ï¼‰
	mux.HandleFunc("/api/catalog", handleCatalog)
	mux.HandleFunc("/api/catalog/usage", handleCatalogUsage)
	mux.HandleFunc("/api/catalog/export", exportCatalogCSV)
	mux.HandleFunc("/api/ingredients", handleIngredients)
	mux.HandleFunc("/api/recipes", handleRecipes)
	mux.HandleFunc("/api/recipes/ingredients", handleRecipeIngredients)
	mux.HandleFunc("/api/locations", handleLocations)
	mux.HandleFunc("/import/catalog", handleCatalogImport)
	mux.HandleFunc("/api/upload", handleUpload)
	mux.HandleFunc("/api/fridge_photos", handleFridgePhotos)

	// é™çš„ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆç”»åƒã¨HTMLï¼‰
	mux.Handle("/images/", http.StripPrefix("/images/", http.FileServer(http.Dir(imagesPath))))

	staticFS, _ := fs.Sub(staticFiles, "static")
	mux.Handle("/", http.FileServer(http.FS(staticFS)))

	fmt.Println("Server is running at http://localhost:8080")

	// â˜…Basicèªè¨¼ã‚’é©ç”¨ã—ã¦èµ·å‹•
	if err := http.ListenAndServe(":8080", basicAuth(mux)); err != nil {
		log.Fatal(err)
	}
}

// Basicèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
func basicAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// â–¼â–¼ ã“ã“ã§IDã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¨­å®šã—ã¦ãã ã•ã„ â–¼â–¼
		const expectedUser = "wasabi"  // â† å¥½ããªIDã«å¤‰æ›´
		const expectedPass = "karashi" // â† å¥½ããªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«å¤‰æ›´
		// â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

		user, pass, ok := r.BasicAuth()
		if !ok || user != expectedUser || pass != expectedPass {
			w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}
		next.ServeHTTP(w, r)
	})
}


----- C:\Users\wasab\OneDrive\ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—\kimichan2\models.go -----
package main

import (
	"database/sql"
	"encoding/json"
)

type CatalogItem struct {
	ID             int    `json:"id"`
	Name           string `json:"name"`
	Kana           string `json:"kana"`
	Classification string `json:"classification"`
	Category       string `json:"category"`
	DefaultUnit    string `json:"default_unit"`
}

type Ingredient struct {
	ID             int     `json:"id"`
	CatalogID      int     `json:"catalog_id"`
	Amount         float64 `json:"amount"`
	Unit           string  `json:"unit"`
	ExpirationDate string  `json:"expiration_date"`
	Location       string  `json:"location"`
	CreatedAt      string  `json:"created_at"`
	UpdatedAt      string  `json:"updated_at"`
	Name           string  `json:"name,omitempty"`
	Kana           string  `json:"kana,omitempty"`
	RecipeCount    int     `json:"recipe_count"`
}

type Seasoning struct {
	ID             int    `json:"id"`
	CatalogID      int    `json:"catalog_id"`
	Status         string `json:"status"`
	CreatedAt      string `json:"created_at"`
	UpdatedAt      string `json:"updated_at"`
	Name           string `json:"name,omitempty"`
	Classification string `json:"classification,omitempty"`
	Category       string `json:"category,omitempty"`
}

type Recipe struct {
	ID                  int                `json:"id"`
	Name                string             `json:"name"`
	Yield               string             `json:"yield"`
	Process             string             `json:"process"`
	OriginalProcess     string             `json:"original_process"` // â˜…è¿½åŠ 
	URL                 string             `json:"url"`
	SourceType          string             `json:"source_type"`
	CreatedAt           string             `json:"created_at"`
	Ingredients         []RecipeIngredient `json:"ingredients,omitempty"`
	OriginalIngredients string             `json:"original_ingredients"` // â˜…è¿½åŠ 
}

type RecipeIngredient struct {
	ID        int    `json:"id"`
	RecipeID  int    `json:"recipe_id"`
	CatalogID int    `json:"catalog_id"`
	Name      string `json:"name"`
	Quantity  string `json:"quantity"`
	GroupName string `json:"group_name"`
}

type FridgePhoto struct {
	ID        int    `json:"id"`
	ImagePath string `json:"image_path"`
	Location  string `json:"location"`
	CreatedAt string `json:"created_at"`
}

type Location struct {
	ID       int    `json:"id"`
	Name     string `json:"name"`
	Priority int    `json:"priority"`
}

type NullString struct {
	sql.NullString
}

func (ns *NullString) Scan(value interface{}) error {
	return ns.NullString.Scan(value)
}

func (ns NullString) MarshalJSON() ([]byte, error) {
	if ns.Valid {
		return json.Marshal(ns.String)
	}
	return json.Marshal(nil)
}


